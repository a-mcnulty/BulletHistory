// Bullet History - Main Panel Script

class BulletHistory {
  constructor() {
    this.historyData = {}; // { domain: { lastVisit, days: { date: { count, urls } } } }
    this.colors = {}; // { domain: color }
    this.dates = [];
    this.sortedDomains = []; // Cached sorted domain list

    // View mode: 'day' (default) or 'hour' - will be loaded from storage in init()
    this.viewMode = 'day';
    this.hours = []; // Array of hour strings like ['2025-12-01T00', '2025-12-01T01', ...]
    this.hourlyData = {}; // { domain: { 'YYYY-MM-DDTHH': { count, urls } } }

    // Virtualization settings
    this.rowHeight = 21; // 18px cell + 3px gap
    this.colWidth = 21; // 18px cell + 3px gap
    this.rowBuffer = 10; // Extra rows to render above/below viewport
    this.colBuffer = 5; // Extra columns to render left/right of viewport

    // Virtualization state
    this.virtualState = {
      startRow: 0,
      endRow: 0,
      startCol: 0,
      endCol: 0,
      viewportHeight: 0,
      viewportWidth: 0
    };

    // DEBUG MODE: Set to true to generate fake history for testing
    this.useFakeData = false;
    this.fakeDomainCount = 100; // Number of domains to generate
    this.fakeDaysBack = 365; // Days of history to generate

    // Open Graph metadata cache (title and description only, no images)
    this.ogCache = new Map();

    this.init();
  }

  async init() {
    // Load saved view mode from localStorage
    const savedViewMode = localStorage.getItem('bulletHistoryViewMode');
    if (savedViewMode === 'hour' || savedViewMode === 'day') {
      this.viewMode = savedViewMode;
    }

    // Initialize state before loading data
    this.selectedCell = null;
    this.expandedViewType = null; // 'cell', 'domain', 'full', 'day', or 'hour'
    this.currentDomain = null; // Track current domain for domain view
    this.currentDate = null; // Track current date for day view
    this.currentHour = null; // Track current hour for hour view
    this.sortMode = 'recent'; // 'recent', 'frequency', or 'alphabetical'
    this.searchFilter = ''; // Search filter text
    this.virtualGridInitialized = false; // Track if listeners are set up
    this.itemsPerPage = 100; // Items per page
    // Track pagination per view type
    this.viewPagination = {
      full: 1,
      recent: 1,
      bookmarks: 1,
      frequent: 1,
      domain: 1,
      cell: 1
    };

    await this.loadColors();
    await this.fetchHistory();

    // Generate dates and hours based on view mode
    this.generateDates();
    if (this.viewMode === 'hour') {
      this.generateHours();
      await this.organizeHistoryByHour();
      this.sortedDomains = this.sortDomainsForHourView();
    } else {
      this.sortedDomains = this.getSortedDomains();
    }
    this.renderDateHeader();
    this.setupVirtualGrid();
    this.setupScrollSync();
    this.setupTooltips();
    this.setupRowHover();
    this.setupColumnHeaderHover();
    this.setupCellClick();
    this.setupLiveUpdates();
    this.setupSortDropdown();
    this.setupSearchInput();
    this.setupBottomMenu();
    this.setupZoomControls();
    this.setupResizeHandle();
    this.setupDateChangeDetection();
    this.setupExpandedViewZoomHandler();

    // Initialize calendar integration
    await this.initializeCalendar();
    this.setupCalendarUI();

    // Initialize view toggle (hour/day)
    this.setupViewToggle();

    // Update toggle button state to reflect saved view mode
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      if (btn.dataset.view === this.viewMode) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    // Re-render date header to show calendar events now that data is loaded
    this.renderDateHeader();

    // Listen for calendar data updates from background sync
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      if (message.type === 'calendarDataUpdated') {
        console.log('Calendar data updated, refreshing UI');
        // Reload calendar data and refresh UI
        this.refreshCalendarUI();
      }
    });

    // Don't show expanded view on load
    // User can open it by clicking a cell or bottom menu buttons

    // Scroll to appropriate position based on view mode
    if (this.viewMode === 'hour') {
      this.scrollToCurrentHour();
    } else {
      this.scrollToToday();
    }
  }

  // Detect when the date changes and update the header
  setupDateChangeDetection() {
    // Store the current date
    let lastDate = this.formatDate(new Date());

    // Update when the page becomes visible again
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const currentDate = this.formatDate(today);

        if (currentDate !== lastDate) {
          // Date changed while user was away!
          lastDate = currentDate;
          this.renderDateHeader();
          this.updateVirtualGrid();
          // Scroll based on view mode
          if (this.viewMode === 'hour') {
            this.scrollToCurrentHour();
          } else {
            this.scrollToToday();
          }
        } else {
          // Date hasn't changed, but still scroll to appropriate position
          if (this.viewMode === 'hour') {
            this.scrollToCurrentHour();
          } else {
            this.scrollToToday();
          }
        }
      }
    });

    // Also check on focus (when side panel is opened)
    window.addEventListener('focus', () => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const currentDate = this.formatDate(today);

      if (currentDate !== lastDate) {
        lastDate = currentDate;
        this.renderDateHeader();
        this.updateVirtualGrid();
        // Scroll based on view mode
        if (this.viewMode === 'hour') {
          this.scrollToCurrentHour();
        } else {
          this.scrollToToday();
        }
      } else {
        // Date hasn't changed, but still scroll to appropriate position
        if (this.viewMode === 'hour') {
          this.scrollToCurrentHour();
        } else {
          this.scrollToToday();
        }
      }
    });
  }

  // Handle zoom changes to recalculate expanded view scroll area
  setupExpandedViewZoomHandler() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const expandedView = document.getElementById('expandedView');
        if (expandedView && expandedView.style.display !== 'none') {
          // Force browser to recalculate scroll area
          expandedView.style.overflow = 'hidden';
          expandedView.offsetHeight; // Force reflow
          expandedView.style.overflow = 'auto';
        }
      }, 100);
    });
  }

  // Generate date range from first to last history date
  generateDates() {
    // Find the earliest visit date from history data
    let earliestDate = new Date();

    for (const domain in this.historyData) {
      for (const dateStr in this.historyData[domain].days) {
        const date = new Date(dateStr);
        if (date < earliestDate) earliestDate = date;
      }
    }

    // Always show through today + 1 week
    const latestDate = new Date();
    latestDate.setHours(0, 0, 0, 0);
    latestDate.setDate(latestDate.getDate() + 7); // Add next week

    // If no history, show last 30 days
    if (!Object.keys(this.historyData).length) {
      earliestDate = new Date();
      earliestDate.setDate(earliestDate.getDate() - 30);
    }

    // Extend earliest date by 1 week
    earliestDate.setDate(earliestDate.getDate() - 7); // Add previous week

    // Generate all dates between (earliest - 1 week) and (today + 1 week)
    this.dates = [];
    const current = new Date(earliestDate);
    current.setHours(0, 0, 0, 0);

    while (current <= latestDate) {
      this.dates.push(this.formatDate(current));
      current.setDate(current.getDate() + 1);
    }

  }

  // Generate hour range from first to last history date
  generateHours() {
    // Find the earliest visit date from history data
    let earliestDate = new Date();

    for (const domain in this.historyData) {
      for (const dateStr in this.historyData[domain].days) {
        const date = new Date(dateStr);
        if (date < earliestDate) earliestDate = date;
      }
    }

    // Always show at least 24 hours into the future from now
    const now = new Date();
    const latestDate = new Date(now.getTime() + (24 * 60 * 60 * 1000)); // Add 24 hours
    latestDate.setMinutes(59, 59, 999); // Round to end of the hour

    // If no history, show last 30 days
    if (!Object.keys(this.historyData).length) {
      earliestDate = new Date();
      earliestDate.setDate(earliestDate.getDate() - 30);
    }

    earliestDate.setHours(0, 0, 0, 0);

    // Generate all hours between earliest and latest
    this.hours = [];
    const current = new Date(earliestDate);

    while (current <= latestDate) {
      const year = current.getFullYear();
      const month = String(current.getMonth() + 1).padStart(2, '0');
      const day = String(current.getDate()).padStart(2, '0');
      const hour = String(current.getHours()).padStart(2, '0');
      const hourStr = `${year}-${month}-${day}T${hour}`;
      this.hours.push(hourStr);
      current.setHours(current.getHours() + 1);
    }

    console.log('Generated hours:', this.hours.length, 'hours from', this.hours[0], 'to', this.hours[this.hours.length - 1]);
  }

  formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  formatDateHeader(dateStr) {
    const date = new Date(dateStr + 'T00:00:00');
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    // Check if it's today or yesterday
    if (this.formatDate(date) === this.formatDate(today)) {
      return 'Today';
    } else if (this.formatDate(date) === this.formatDate(yesterday)) {
      return 'Yesterday';
    }

    // Otherwise, format as "Day, Month Date, Year" (e.g., "Monday, Dec 23, 2025")
    const options = { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  }

  // Fetch Chrome history (all available) or generate fake data
  async fetchHistory() {
    if (this.useFakeData) {
      this.generateFakeHistory();
      return Promise.resolve();
    }

    return new Promise((resolve) => {
      chrome.history.search({
        text: '',
        startTime: 0, // Get all history
        maxResults: 0  // No limit
      }, (results) => {
        this.parseHistory(results);
        resolve();
      });
    });
  }

  // Generate fake history data for testing
  generateFakeHistory() {
    this.historyData = {};

    const fakeDomains = [
      'google.com', 'github.com', 'stackoverflow.com', 'reddit.com', 'twitter.com',
      'youtube.com', 'facebook.com', 'amazon.com', 'netflix.com', 'linkedin.com',
      'wikipedia.org', 'medium.com', 'dev.to', 'hackernews.com', 'producthunt.com',
      'dribbble.com', 'behance.net', 'figma.com', 'notion.so', 'slack.com',
      'discord.com', 'twitch.tv', 'spotify.com', 'soundcloud.com', 'pinterest.com',
      'instagram.com', 'tiktok.com', 'snapchat.com', 'tumblr.com', 'vimeo.com',
      'dropbox.com', 'drive.google.com', 'docs.google.com', 'sheets.google.com',
      'mail.google.com', 'outlook.com', 'zoom.us', 'meet.google.com', 'teams.microsoft.com',
      'trello.com', 'asana.com', 'jira.atlassian.com', 'confluence.atlassian.com',
      'gitlab.com', 'bitbucket.org', 'docker.com', 'kubernetes.io', 'aws.amazon.com',
      'azure.microsoft.com', 'cloud.google.com', 'heroku.com', 'vercel.com', 'netlify.com'
    ];

    // Generate additional random domains to reach fakeDomainCount
    while (fakeDomains.length < this.fakeDomainCount) {
      const randomName = Math.random().toString(36).substring(7);
      fakeDomains.push(`${randomName}.com`);
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // For each domain, generate random visit data
    fakeDomains.forEach(domain => {
      const lastVisit = Date.now() - Math.random() * (this.fakeDaysBack * 24 * 60 * 60 * 1000);

      this.historyData[domain] = {
        lastVisit: lastVisit,
        days: {}
      };

      // Generate visits for random days
      const numDaysWithVisits = Math.floor(Math.random() * this.fakeDaysBack * 0.3); // Visit 30% of days on average

      for (let i = 0; i < numDaysWithVisits; i++) {
        const daysAgo = Math.floor(Math.random() * this.fakeDaysBack);
        const date = new Date(today);
        date.setDate(date.getDate() - daysAgo);
        const dateStr = this.formatDate(date);

        if (!this.historyData[domain].days[dateStr]) {
          const visitCount = Math.floor(Math.random() * 50) + 1; // 1-50 visits per day
          this.historyData[domain].days[dateStr] = {
            count: visitCount,
            urls: Array(Math.min(visitCount, 10)).fill(null).map((_, idx) => ({
              url: `https://${domain}/page${idx}`,
              title: `Page ${idx} - ${domain}`,
              lastVisit: date.getTime(),
              visitCount: 1
            }))
          };
        }
      }
    });

    // Generate colors for all domains
    for (const domain in this.historyData) {
      if (!this.colors[domain]) {
        this.colors[domain] = this.generatePastelColor();
      }
    }

  }

  // Parse history into domain/day structure
  parseHistory(results) {
    this.historyData = {};


    for (const item of results) {
      try {
        const url = new URL(item.url);
        const domain = url.hostname.replace('www.', '');

        // Create date from timestamp and normalize to local midnight
        const visitDateObj = new Date(item.lastVisitTime);
        visitDateObj.setHours(0, 0, 0, 0);
        const visitDate = this.formatDate(visitDateObj);

        if (!this.historyData[domain]) {
          this.historyData[domain] = {
            lastVisit: item.lastVisitTime,
            days: {}
          };
        }

        if (!this.historyData[domain].days[visitDate]) {
          this.historyData[domain].days[visitDate] = {
            count: 0,
            urls: []
          };
        }

        // Update last visit if more recent
        if (item.lastVisitTime > this.historyData[domain].lastVisit) {
          this.historyData[domain].lastVisit = item.lastVisitTime;
        }

        this.historyData[domain].days[visitDate].count += item.visitCount || 1;
        this.historyData[domain].days[visitDate].urls.push({
          url: item.url,
          title: item.title,
          lastVisit: item.lastVisitTime,
          visitCount: item.visitCount || 1
        });

      } catch (e) {
        // Skip invalid URLs
        console.warn('Invalid URL:', item.url);
      }
    }

    // Generate colors for new domains
    for (const domain in this.historyData) {
      if (!this.colors[domain]) {
        this.colors[domain] = this.generatePastelColor();
      }
    }

    // Debug: show unique dates in history data
    const allDates = new Set();
    for (const domain in this.historyData) {
      for (const date in this.historyData[domain].days) {
        allDates.add(date);
      }
    }

    this.saveColors();
  }

  // Generate a random pastel color
  generatePastelColor() {
    const hue = Math.floor(Math.random() * 360);
    const saturation = 60 + Math.floor(Math.random() * 20); // 60-80%
    const lightness = 80 + Math.floor(Math.random() * 10);  // 80-90%
    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
  }

  // Load colors from storage
  async loadColors() {
    return new Promise((resolve) => {
      chrome.storage.local.get(['domainColors'], (result) => {
        this.colors = result.domainColors || {};
        resolve();
      });
    });
  }

  // Save colors to storage
  saveColors() {
    chrome.storage.local.set({ domainColors: this.colors });
  }

  // Get sorted domains based on current sort mode and filter
  getSortedDomains() {
    let domains = Object.keys(this.historyData);

    // Apply search filter
    if (this.searchFilter) {
      const filterLower = this.searchFilter.toLowerCase();
      domains = domains.filter(domain => domain.toLowerCase().includes(filterLower));
    }

    // Apply sort
    switch (this.sortMode) {
      case 'recent':
        // Most recent visit first
        return domains.sort((a, b) => {
          return this.historyData[b].lastVisit - this.historyData[a].lastVisit;
        });

      case 'popular':
        // Most days with visits first
        return domains.sort((a, b) => {
          const aDays = Object.keys(this.historyData[a].days).length;
          const bDays = Object.keys(this.historyData[b].days).length;
          return bDays - aDays;
        });

      case 'alphabetical':
        // A to Z
        return domains.sort((a, b) => a.localeCompare(b));

      default:
        return domains;
    }
  }

  // Get sorted domains for hour view
  sortDomainsForHourView() {
    let domains = Object.keys(this.hourlyData);
    console.log('sortDomainsForHourView: Starting with', domains.length, 'domains from hourlyData');

    // Apply search filter
    if (this.searchFilter) {
      const filterLower = this.searchFilter.toLowerCase();
      domains = domains.filter(domain => domain.toLowerCase().includes(filterLower));
    }

    // Apply sort
    switch (this.sortMode) {
      case 'recent':
        // Most recent visit first (check all URLs in all hours)
        return domains.sort((a, b) => {
          let aMaxTime = 0;
          let bMaxTime = 0;

          Object.values(this.hourlyData[a]).forEach(hourData => {
            hourData.urls.forEach(url => {
              aMaxTime = Math.max(aMaxTime, url.lastVisitTime);
            });
          });

          Object.values(this.hourlyData[b]).forEach(hourData => {
            hourData.urls.forEach(url => {
              bMaxTime = Math.max(bMaxTime, url.lastVisitTime);
            });
          });

          return bMaxTime - aMaxTime;
        });

      case 'popular':
        // Most total visits in the day
        return domains.sort((a, b) => {
          let aTotal = 0;
          let bTotal = 0;

          Object.values(this.hourlyData[a]).forEach(hourData => {
            aTotal += hourData.count;
          });

          Object.values(this.hourlyData[b]).forEach(hourData => {
            bTotal += hourData.count;
          });

          return bTotal - aTotal;
        });

      case 'alphabetical':
        // A to Z
        return domains.sort((a, b) => a.localeCompare(b));

      default:
        return domains;
    }
  }

  // Render date header
  renderDateHeader() {
    console.log('renderDateHeader called, viewMode:', this.viewMode);

    // Check if we're in hour view mode
    if (this.viewMode === 'hour') {
      this.renderHourHeader();
      return;
    }

    // Remove hour-view class when in day view
    document.querySelector('.container').classList.remove('hour-view');

    const monthRow = document.getElementById('monthRow');
    const calendarEventsRow = document.getElementById('calendarEventsRow');
    const weekdayRow = document.getElementById('weekdayRow');
    const dayRow = document.getElementById('dayRow');

    monthRow.innerHTML = '';
    calendarEventsRow.innerHTML = '';
    weekdayRow.innerHTML = '';
    dayRow.innerHTML = '';

    let currentMonth = '';
    let monthSpan = 0;

    // Get today's date string for comparison
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStr = this.formatDate(today);

    this.dates.forEach((dateStr, index) => {
      const date = new Date(dateStr + 'T00:00:00'); // Add time to avoid timezone issues

      // Check for invalid date
      if (isNaN(date.getTime())) {
        console.error(`Invalid date: ${dateStr}`);
        return;
      }

      const monthName = date.toLocaleString('en-US', { month: 'long' });
      const year = date.getFullYear();
      const monthYearKey = `${monthName} ${year}`;
      const dayNum = date.getDate();
      const weekdayName = date.toLocaleString('en-US', { weekday: 'short' }).charAt(0);

      // Check if this is today
      const isToday = dateStr === todayStr;

      // Debug first few dates
      if (index < 3 || index > this.dates.length - 3) {
      }

      // Month header (only show when month changes)
      if (monthYearKey !== currentMonth) {
        if (monthSpan > 0) {
          // Create month cell for previous month
          const monthCell = document.createElement('div');
          monthCell.className = 'month-cell';
          monthCell.style.width = `${monthSpan * 21 - 3}px`; // 18px cell + 3px gap per day, minus last gap
          monthCell.style.minWidth = `${monthSpan * 21 - 3}px`;
          monthCell.textContent = currentMonth;
          monthRow.appendChild(monthCell);
        }
        currentMonth = monthYearKey;
        monthSpan = 1;
      } else {
        monthSpan++;
      }

      // Calendar events column
      const eventColumn = document.createElement('div');
      eventColumn.className = 'calendar-event-column';
      eventColumn.dataset.date = dateStr;

      // Render events (if any)
      const hasEvents = this.renderCalendarEventColumn(eventColumn, dateStr);

      // Set empty columns to zero height to save vertical space
      if (!hasEvents) {
        eventColumn.style.height = '0';
        eventColumn.style.padding = '0';
      } else if (isToday) {
        eventColumn.classList.add('col-today');
      }

      // Add click handler to switch to hour view for this day
      eventColumn.addEventListener('click', () => {
        this.switchToHourViewForDate(dateStr);
      });
      eventColumn.style.cursor = 'pointer';

      calendarEventsRow.appendChild(eventColumn);

      // Weekday letter
      const weekdayCell = document.createElement('div');
      weekdayCell.className = 'weekday-cell';
      if (isToday) weekdayCell.classList.add('col-today');
      weekdayCell.textContent = weekdayName;
      weekdayCell.dataset.colIndex = index;
      weekdayCell.dataset.date = dateStr;

      // Add click handler to switch to hour view for this day
      weekdayCell.addEventListener('click', () => {
        this.switchToHourViewForDate(dateStr);
      });
      weekdayCell.style.cursor = 'pointer';

      weekdayRow.appendChild(weekdayCell);

      // Day number
      const dayCell = document.createElement('div');
      dayCell.className = 'day-cell';
      if (isToday) dayCell.classList.add('col-today');
      dayCell.textContent = dayNum;
      dayCell.dataset.colIndex = index;
      dayCell.dataset.date = dateStr;

      // Add click handler to switch to hour view for this day
      dayCell.addEventListener('click', () => {
        this.switchToHourViewForDate(dateStr);
      });
      dayCell.style.cursor = 'pointer';

      dayRow.appendChild(dayCell);

      // Last month cell
      if (index === this.dates.length - 1) {
        const monthCell = document.createElement('div');
        monthCell.className = 'month-cell';
        monthCell.style.width = `${monthSpan * 21 - 3}px`; // 18px cell + 3px gap per day, minus last gap
        monthCell.style.minWidth = `${monthSpan * 21 - 3}px`;
        monthCell.textContent = currentMonth;
        monthRow.appendChild(monthCell);
      }
    });
  }

  // Render hour header for hour view
  renderHourHeader() {
    console.log('renderHourHeader called, hours:', this.hours.length);

    // Add class to container to enable hour-view specific CSS
    document.querySelector('.container').classList.add('hour-view');

    const monthRow = document.getElementById('monthRow');
    const calendarEventsRow = document.getElementById('calendarEventsRow');
    const weekdayRow = document.getElementById('weekdayRow');
    const dayRow = document.getElementById('dayRow');

    monthRow.innerHTML = '';
    calendarEventsRow.innerHTML = '';
    weekdayRow.innerHTML = '';
    dayRow.innerHTML = '';

    // Get current hour string for highlighting
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const currentHour = String(now.getHours()).padStart(2, '0');
    const currentHourStr = `${year}-${month}-${day}T${currentHour}`;

    let currentDay = '';
    let daySpan = 0;

    // Iterate through all hours
    this.hours.forEach((hourStr, index) => {
      // Parse hourStr like '2025-12-01T00'
      const [datePart, hourPart] = hourStr.split('T');
      const date = new Date(datePart + 'T00:00:00');
      const hour = parseInt(hourPart);

      // Check if this is the current hour
      const isCurrentHour = hourStr === currentHourStr;

      // Month/Year line: "January 2026"
      const monthYear = date.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric'
      });

      // Weekday/Day line: "Saturday 3rd"
      const weekdayName = date.toLocaleDateString('en-US', { weekday: 'long' });
      const dayNum = date.getDate();

      // Add ordinal suffix (st, nd, rd, th)
      const getOrdinalSuffix = (day) => {
        if (day > 3 && day < 21) return 'th';
        switch (day % 10) {
          case 1: return 'st';
          case 2: return 'nd';
          case 3: return 'rd';
          default: return 'th';
        }
      };
      const weekdayDay = `${weekdayName} ${dayNum}${getOrdinalSuffix(dayNum)}`;

      // Combine for tracking day changes
      const dayBanner = `${monthYear}|${weekdayDay}`;

      // Calendar events column
      const eventColumn = document.createElement('div');
      eventColumn.className = 'calendar-event-column';
      eventColumn.dataset.date = hourStr;
      if (isCurrentHour) eventColumn.classList.add('col-today');

      // Render events (if any) for this specific hour
      const hasEvents = this.renderCalendarEventColumnForHour(eventColumn, hourStr);

      // Set empty columns to zero height to save vertical space
      if (!hasEvents) {
        eventColumn.style.height = '0';
        eventColumn.style.padding = '0';
      } else {
        // Make event column clickable if it has events
        eventColumn.style.cursor = 'pointer';
        eventColumn.addEventListener('click', () => {
          this.showHourExpandedView(hourStr);
        });
      }

      calendarEventsRow.appendChild(eventColumn);

      // Day banner (show when day changes) - spans 24 hours
      if (dayBanner !== currentDay) {
        if (daySpan > 0) {
          // Split the stored banner back into parts
          const [prevMonthYear, prevWeekdayDay] = currentDay.split('|');

          const bannerCell = document.createElement('div');
          bannerCell.className = 'weekday-cell hour-view-day-banner';
          bannerCell.style.width = `${daySpan * 21 - 3}px`;
          bannerCell.style.minWidth = `${daySpan * 21 - 3}px`;
          bannerCell.style.textAlign = 'center';
          bannerCell.style.display = 'flex';
          bannerCell.style.flexDirection = 'column';
          bannerCell.style.alignItems = 'center';
          bannerCell.style.gap = '2px';
          bannerCell.style.padding = '4px 0';

          // Month/Year line (clickable to switch back to day view)
          const monthYearDiv = document.createElement('div');
          monthYearDiv.className = 'hour-view-month-year';
          monthYearDiv.style.fontWeight = '700';
          monthYearDiv.style.fontSize = '11px';
          monthYearDiv.style.cursor = 'pointer';
          monthYearDiv.style.color = '#4285f4';
          monthYearDiv.style.transition = 'opacity 0.15s ease';
          monthYearDiv.textContent = prevMonthYear;
          monthYearDiv.title = 'Click to switch to day view';

          // Add hover effect
          monthYearDiv.addEventListener('mouseenter', () => {
            monthYearDiv.style.opacity = '0.7';
          });
          monthYearDiv.addEventListener('mouseleave', () => {
            monthYearDiv.style.opacity = '1';
          });

          // Click to switch to day view
          monthYearDiv.addEventListener('click', async () => {
            await this.switchView('day');
          });

          // Weekday/Day line
          const weekdayDayDiv = document.createElement('div');
          weekdayDayDiv.className = 'hour-view-weekday-day';
          weekdayDayDiv.style.fontWeight = '600';
          weekdayDayDiv.style.fontSize = '10px';
          weekdayDayDiv.style.color = '#666';
          weekdayDayDiv.textContent = prevWeekdayDay;

          bannerCell.appendChild(monthYearDiv);
          bannerCell.appendChild(weekdayDayDiv);
          weekdayRow.appendChild(bannerCell);
        }
        currentDay = dayBanner;
        daySpan = 1;
      } else {
        daySpan++;
      }

      // Hour number - use two-line format (AM/PM + 12-hour)
      const hourCell = document.createElement('div');
      hourCell.className = 'day-cell hour-cell';
      if (isCurrentHour) hourCell.classList.add('col-today');
      hourCell.dataset.colIndex = index; // Add column index for hover functionality
      hourCell.dataset.hourStr = hourStr; // Store hour string for click handler
      hourCell.style.cursor = 'pointer'; // Make it clickable

      // Create two-line layout
      hourCell.style.display = 'flex';
      hourCell.style.flexDirection = 'column';
      hourCell.style.alignItems = 'center';
      hourCell.style.justifyContent = 'center';
      hourCell.style.gap = '0';
      hourCell.style.lineHeight = '1';

      // AM/PM line
      const ampmDiv = document.createElement('div');
      ampmDiv.style.fontSize = '8px';
      ampmDiv.style.fontWeight = '500';
      ampmDiv.style.color = '#999';
      ampmDiv.textContent = hour >= 12 ? 'PM' : 'AM';

      // Hour number line (12-hour format)
      const hourNumDiv = document.createElement('div');
      hourNumDiv.style.fontSize = '11px';
      hourNumDiv.style.fontWeight = '600';
      const hour12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
      hourNumDiv.textContent = hour12;

      // Add click handler to show hour expanded view
      hourCell.addEventListener('click', () => {
        this.showHourExpandedView(hourStr);
      });

      hourCell.appendChild(ampmDiv);
      hourCell.appendChild(hourNumDiv);
      dayRow.appendChild(hourCell);

      // Last day banner
      if (index === this.hours.length - 1) {
        // Split the stored banner back into parts
        const [lastMonthYear, lastWeekdayDay] = currentDay.split('|');

        const bannerCell = document.createElement('div');
        bannerCell.className = 'weekday-cell hour-view-day-banner';
        bannerCell.style.width = `${daySpan * 21 - 3}px`;
        bannerCell.style.minWidth = `${daySpan * 21 - 3}px`;
        bannerCell.style.textAlign = 'center';
        bannerCell.style.display = 'flex';
        bannerCell.style.flexDirection = 'column';
        bannerCell.style.alignItems = 'center';
        bannerCell.style.gap = '2px';
        bannerCell.style.padding = '4px 0';

        // Month/Year line (clickable to switch back to day view)
        const monthYearDiv = document.createElement('div');
        monthYearDiv.className = 'hour-view-month-year';
        monthYearDiv.style.fontWeight = '700';
        monthYearDiv.style.fontSize = '11px';
        monthYearDiv.style.cursor = 'pointer';
        monthYearDiv.style.color = '#4285f4';
        monthYearDiv.style.transition = 'opacity 0.15s ease';
        monthYearDiv.textContent = lastMonthYear;
        monthYearDiv.title = 'Click to switch to day view';

        // Add hover effect
        monthYearDiv.addEventListener('mouseenter', () => {
          monthYearDiv.style.opacity = '0.7';
        });
        monthYearDiv.addEventListener('mouseleave', () => {
          monthYearDiv.style.opacity = '1';
        });

        // Click to switch to day view
        monthYearDiv.addEventListener('click', async () => {
          await this.switchView('day');
        });

        // Weekday/Day line
        const weekdayDayDiv = document.createElement('div');
        weekdayDayDiv.className = 'hour-view-weekday-day';
        weekdayDayDiv.style.fontWeight = '600';
        weekdayDayDiv.style.fontSize = '10px';
        weekdayDayDiv.style.color = '#666';
        weekdayDayDiv.textContent = lastWeekdayDay;

        bannerCell.appendChild(monthYearDiv);
        bannerCell.appendChild(weekdayDayDiv);
        weekdayRow.appendChild(bannerCell);
      }
    });
  }

  // Get GitHub-style color based on visit count
  // Uses discrete levels like GitHub's contribution graph
  getGitHubStyleColor(count, maxCount, baseColor) {
    if (count === 0) return '#ebedf0'; // GitHub's empty cell color (light gray)

    // Calculate which quartile this count falls into
    const normalized = count / maxCount;

    // GitHub uses 4 distinct levels
    // Parse the base color to get the hue
    const hslMatch = baseColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
    const hue = hslMatch ? hslMatch[1] : '140'; // Default to green if parsing fails

    if (normalized <= 0.25) {
      // Level 1: Lightest (1-25%)
      return `hsl(${hue}, 42%, 86%)`;
    } else if (normalized <= 0.5) {
      // Level 2: Light-medium (26-50%)
      return `hsl(${hue}, 50%, 76%)`;
    } else if (normalized <= 0.75) {
      // Level 3: Medium-dark (51-75%)
      return `hsl(${hue}, 54%, 66%)`;
    } else {
      // Level 4: Darkest (76-100%) - dialed back one more step
      return `hsl(${hue}, 58%, 60%)`;
    }
  }

  // Setup virtual grid with spacers
  setupVirtualGrid() {
    const tldColumn = document.getElementById('tldColumn');
    const cellGridWrapper = document.getElementById('cellGridWrapper');
    const cellGrid = document.getElementById('cellGrid');

    // Calculate total dimensions
    const totalHeight = this.sortedDomains.length * this.rowHeight + 11; // Add top (8px) + bottom (3px) padding
    const columnCount = this.viewMode === 'hour' ? this.hours.length : this.dates.length;
    const totalWidth = columnCount * this.colWidth;

    // Create spacer to maintain scroll area
    tldColumn.innerHTML = '<div class="virtual-spacer"></div>';
    cellGrid.innerHTML = '<div class="virtual-spacer"></div>';

    const tldSpacer = tldColumn.querySelector('.virtual-spacer');
    const cellSpacer = cellGrid.querySelector('.virtual-spacer');

    tldSpacer.style.height = `${totalHeight}px`;
    tldSpacer.style.width = '1px';
    cellSpacer.style.height = `${totalHeight}px`;
    // Width calculation: (N dates * 21px) - 3px (last gap) + 16px (left+right padding) = N*21 + 13
    cellSpacer.style.width = `${totalWidth + 13}px`; // Match date-header-inner width

    // Initial render
    this.updateVirtualGrid();

    // Only add listeners on first setup
    if (!this.virtualGridInitialized) {
      // Re-render on scroll
      cellGridWrapper.addEventListener('scroll', () => {
        this.updateVirtualGrid();
      });

      // Re-render on resize
      window.addEventListener('resize', () => {
        this.updateVirtualGrid();
      });

      this.virtualGridInitialized = true;
    }
  }

  // Update which rows/columns are visible and render them
  updateVirtualGrid(forceUpdate = false) {
    const tldColumn = document.getElementById('tldColumn');
    const cellGridWrapper = document.getElementById('cellGridWrapper');
    const cellGrid = document.getElementById('cellGrid');

    // Get viewport dimensions
    const viewportHeight = cellGridWrapper.clientHeight;
    const viewportWidth = cellGridWrapper.clientWidth;
    const scrollTop = cellGridWrapper.scrollTop;
    const scrollLeft = cellGridWrapper.scrollLeft;

    // Calculate visible range with buffer
    const startRow = Math.max(0, Math.floor(scrollTop / this.rowHeight) - this.rowBuffer);
    const endRow = Math.min(
      this.sortedDomains.length,
      Math.ceil((scrollTop + viewportHeight) / this.rowHeight) + this.rowBuffer
    );

    const startCol = Math.max(0, Math.floor(scrollLeft / this.colWidth) - this.colBuffer);
    const columnCount = this.viewMode === 'hour' ? this.hours.length : this.dates.length;
    const endCol = Math.min(
      columnCount,
      Math.ceil((scrollLeft + viewportWidth) / this.colWidth) + this.colBuffer
    );


    // Only update if range changed (unless forced)
    if (
      !forceUpdate &&
      startRow === this.virtualState.startRow &&
      endRow === this.virtualState.endRow &&
      startCol === this.virtualState.startCol &&
      endCol === this.virtualState.endCol
    ) {
      return;
    }

    this.virtualState = { startRow, endRow, startCol, endCol, viewportHeight, viewportWidth };

    // Render visible rows
    this.renderVirtualRows(startRow, endRow, startCol, endCol);
  }

  // Render only visible rows
  renderVirtualRows(startRow, endRow, startCol, endCol) {
    const tldColumn = document.getElementById('tldColumn');
    const cellGrid = document.getElementById('cellGrid');

    // Clear existing rows (keep spacer)
    const tldSpacer = tldColumn.querySelector('.virtual-spacer');
    const cellSpacer = cellGrid.querySelector('.virtual-spacer');
    tldColumn.innerHTML = '';
    cellGrid.innerHTML = '';
    tldColumn.appendChild(tldSpacer);
    cellGrid.appendChild(cellSpacer);

    // Get today's date string for comparison (day view)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStr = this.formatDate(today);
    const todayIndex = this.dates.indexOf(todayStr);

    // Get current hour string for comparison (hour view)
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const currentHour = String(now.getHours()).padStart(2, '0');
    const currentHourStr = `${year}-${month}-${day}T${currentHour}`;
    const currentHourIndex = this.hours.indexOf(currentHourStr);

    // Render visible rows
    for (let rowIndex = startRow; rowIndex < endRow; rowIndex++) {
      const domain = this.sortedDomains[rowIndex];
      if (!domain) continue;

      // Find max visit count for THIS DOMAIN (row-normalized)
      let maxCount = 0;
      if (this.viewMode === 'hour') {
        // In hour view, find max hourly count
        if (this.hourlyData[domain]) {
          Object.values(this.hourlyData[domain]).forEach(hourData => {
            maxCount = Math.max(maxCount, hourData.count);
          });
        }
      } else {
        // In day view, find max daily count
        Object.values(this.historyData[domain].days).forEach(day => {
          maxCount = Math.max(maxCount, day.count);
        });
      }

      // TLD label
      const tldRow = document.createElement('div');
      tldRow.className = 'tld-row';
      tldRow.dataset.rowIndex = rowIndex;
      tldRow.style.position = 'absolute';
      tldRow.style.top = `${rowIndex * this.rowHeight + 8}px`; // Add 8px padding
      tldRow.style.width = '100%';

      // Favicon
      const favicon = document.createElement('img');
      favicon.className = 'tld-favicon';
      favicon.src = `https://www.google.com/s2/favicons?domain=${domain}&sz=16`;
      favicon.alt = '';
      favicon.width = 16;
      favicon.height = 16;
      tldRow.appendChild(favicon);

      // Domain name span
      const domainSpan = document.createElement('span');
      domainSpan.className = 'tld-name';
      domainSpan.textContent = domain;
      tldRow.appendChild(domainSpan);

      // Delete button (shown on hover)
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'tld-delete-btn';
      deleteBtn.innerHTML = 'ðŸ—‘ï¸';
      deleteBtn.title = 'Delete all history for this domain';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent row click
        // Find the TLD row element and animate it
        const tldRow = e.target.closest('.tld-row');
        this.deleteDomainWithAnimation(tldRow, domain);
      });
      tldRow.appendChild(deleteBtn);

      tldColumn.appendChild(tldRow);

      // Cell row
      const cellRow = document.createElement('div');
      cellRow.className = 'cell-row';
      cellRow.dataset.rowIndex = rowIndex;
      cellRow.style.position = 'absolute';
      cellRow.style.top = `${rowIndex * this.rowHeight + 8}px`; // Add 8px padding
      cellRow.style.left = '0';
      const columnCount = this.viewMode === 'hour' ? this.hours.length : this.dates.length;
      cellRow.style.width = `${columnCount * this.colWidth + 13}px`; // Match date-header-inner width

      // Add today/current hour column highlight
      if (this.viewMode === 'day' && todayIndex !== -1) {
        cellRow.classList.add('has-today-col');
        // Add special class for first row to extend highlight upward
        if (rowIndex === startRow) {
          cellRow.classList.add('first-row-today');
        }
        const todayColLeft = todayIndex * this.colWidth + 8 - 1; // Position to center the 20px highlight (1px padding on each side)
        cellRow.style.setProperty('--today-col-left', `${todayColLeft}px`);
      } else if (this.viewMode === 'hour' && currentHourIndex !== -1) {
        cellRow.classList.add('has-today-col');
        // Add special class for first row to extend highlight upward
        if (rowIndex === startRow) {
          cellRow.classList.add('first-row-today');
        }
        const currentHourColLeft = currentHourIndex * this.colWidth + 8 - 1;
        cellRow.style.setProperty('--today-col-left', `${currentHourColLeft}px`);
      }

      // Render visible columns
      for (let colIndex = startCol; colIndex < endCol; colIndex++) {
        let columnKey, visitData;

        if (this.viewMode === 'hour') {
          // Hour view: column key is hour (0-23)
          columnKey = this.hours[colIndex];
          if (columnKey === undefined) continue;
          visitData = this.hourlyData[domain]?.[columnKey];
        } else {
          // Day view: column key is date string
          columnKey = this.dates[colIndex];
          if (!columnKey) continue;
          visitData = this.historyData[domain].days[columnKey];
        }

        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.domain = domain;
        cell.dataset.date = columnKey; // columnKey is hourStr in hour view, dateStr in day view
        cell.dataset.colIndex = colIndex;
        cell.dataset.rowIndex = rowIndex;
        cell.style.position = 'absolute';
        cell.style.left = `${colIndex * this.colWidth + 8}px`; // Add left padding

        // Check if this is today's column (day view) or current hour (hour view)
        if (this.viewMode === 'day' && columnKey === todayStr) {
          cell.classList.add('col-today');
        } else if (this.viewMode === 'hour' && columnKey === currentHourStr) {
          cell.classList.add('col-today');
        }

        if (visitData && visitData.count > 0) {
          const baseColor = this.colors[domain];
          // Use GitHub-style discrete color levels
          cell.style.backgroundColor = this.getGitHubStyleColor(visitData.count, maxCount, baseColor);

          cell.dataset.count = visitData.count;
        } else {
          cell.classList.add('empty');
          cell.dataset.count = 0;
        }

        cellRow.appendChild(cell);
      }

      cellGrid.appendChild(cellRow);
    }
  }

  // Sync scrolling between date header and cell grid
  setupScrollSync() {
    const dateHeader = document.getElementById('dateHeader');
    const cellGridWrapper = document.getElementById('cellGridWrapper');
    const tldColumn = document.getElementById('tldColumn');

    let isHeaderScrolling = false;
    let isGridScrolling = false;
    let isTldScrolling = false;

    // Helper function to clear all hover states
    const clearAllHoverStates = () => {
      // Clear column hover states
      document.querySelectorAll('.col-hover').forEach(el => {
        el.classList.remove('col-hover');
      });
      // Clear row hover states
      document.querySelectorAll('.row-hover').forEach(el => {
        el.classList.remove('row-hover');
      });
    };

    // Sync horizontal scroll: grid -> header
    // Sync vertical scroll: grid -> tld column
    cellGridWrapper.addEventListener('scroll', () => {
      if (isHeaderScrolling || isTldScrolling) return;
      isGridScrolling = true;
      clearAllHoverStates(); // Clear hover states when scrolling
      dateHeader.scrollLeft = cellGridWrapper.scrollLeft;
      tldColumn.scrollTop = cellGridWrapper.scrollTop;
      requestAnimationFrame(() => {
        isGridScrolling = false;
      });
    }, { passive: true });

    // Sync horizontal scroll: header -> grid
    dateHeader.addEventListener('scroll', () => {
      if (isGridScrolling) return;
      isHeaderScrolling = true;
      clearAllHoverStates(); // Clear hover states when scrolling
      cellGridWrapper.scrollLeft = dateHeader.scrollLeft;
      requestAnimationFrame(() => {
        isHeaderScrolling = false;
      });
    }, { passive: true });

    // Sync vertical scroll: tld column -> grid
    tldColumn.addEventListener('scroll', () => {
      if (isGridScrolling) return;
      isTldScrolling = true;
      clearAllHoverStates(); // Clear hover states when scrolling
      cellGridWrapper.scrollTop = tldColumn.scrollTop;
      requestAnimationFrame(() => {
        isTldScrolling = false;
      });
    }, { passive: true });

    // Scroll to show today (right edge)
    cellGridWrapper.scrollLeft = cellGridWrapper.scrollWidth;
  }

  // Setup hover tooltips
  setupTooltips() {
    const tooltip = document.getElementById('tooltip');
    const cellGrid = document.getElementById('cellGrid');

    cellGrid.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('cell')) {
        const count = parseInt(e.target.dataset.count) || 0;
        const domain = e.target.dataset.domain;
        const date = e.target.dataset.date;

        if (count > 0) {
          tooltip.textContent = `${count} visit${count !== 1 ? 's' : ''}`;
          tooltip.classList.add('visible');

          // Position tooltip near cursor
          const rect = e.target.getBoundingClientRect();
          tooltip.style.left = `${rect.left + rect.width / 2}px`;
          tooltip.style.top = `${rect.top - 30}px`;
          tooltip.style.transform = 'translateX(-50%)';
        }
      }
    });

    cellGrid.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('cell')) {
        tooltip.classList.remove('visible');
      }
    });
  }

  // Setup row hover highlighting
  setupRowHover() {
    const tldColumn = document.getElementById('tldColumn');
    const cellGrid = document.getElementById('cellGrid');
    const weekdayRow = document.getElementById('weekdayRow');
    const dayRow = document.getElementById('dayRow');

    // Click on TLD row to show full domain view
    tldColumn.addEventListener('click', (e) => {
      // Find the tld-row element (could be the target or a parent)
      const tldRow = e.target.closest('.tld-row');
      if (tldRow) {
        const rowIndex = tldRow.dataset.rowIndex;
        const domain = this.sortedDomains[rowIndex];

        if (domain) {
          // Close any existing expanded view
          if (this.selectedCell) {
            this.selectedCell.classList.remove('selected');
            this.selectedCell = null;
          }

          // Show domain view
          this.showDomainView(domain);
        }
      }
    });

    // Hover over TLD row
    tldColumn.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('tld-row')) {
        const rowIndex = e.target.dataset.rowIndex;
        // Highlight the TLD row
        e.target.classList.add('row-hover');
        // Highlight the corresponding cell row
        const cellRow = cellGrid.querySelector(`.cell-row[data-row-index="${rowIndex}"]`);
        if (cellRow) {
          cellRow.classList.add('row-hover');
        }
      }
    });

    tldColumn.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('tld-row')) {
        const rowIndex = e.target.dataset.rowIndex;
        // Remove highlight from TLD row
        e.target.classList.remove('row-hover');
        // Remove highlight from cell row
        const cellRow = cellGrid.querySelector(`.cell-row[data-row-index="${rowIndex}"]`);
        if (cellRow) {
          cellRow.classList.remove('row-hover');
        }
      }
    });

    // Hover over cell
    cellGrid.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('cell')) {
        const rowIndex = e.target.dataset.rowIndex;
        const colIndex = e.target.dataset.colIndex;

        // Highlight the TLD row
        const tldRow = tldColumn.querySelector(`.tld-row[data-row-index="${rowIndex}"]`);
        if (tldRow) {
          tldRow.classList.add('row-hover');
        }

        // Highlight the cell row
        const cellRow = cellGrid.querySelector(`.cell-row[data-row-index="${rowIndex}"]`);
        if (cellRow) {
          cellRow.classList.add('row-hover');
        }

        // Highlight the weekday cell
        const weekdayCell = weekdayRow.querySelector(`.weekday-cell[data-col-index="${colIndex}"]`);
        if (weekdayCell) {
          weekdayCell.classList.add('col-hover');
        }

        // Highlight the day cell
        const dayCell = dayRow.querySelector(`.day-cell[data-col-index="${colIndex}"]`);
        if (dayCell) {
          dayCell.classList.add('col-hover');
        }

        // Highlight the calendar event column
        const calendarEventsRow = document.getElementById('calendarEventsRow');
        if (calendarEventsRow) {
          const eventColumns = calendarEventsRow.children;
          if (eventColumns[colIndex]) {
            eventColumns[colIndex].classList.add('col-hover');
          }
        }

        // Highlight all cells in the column
        const columnCells = cellGrid.querySelectorAll(`.cell[data-col-index="${colIndex}"]`);
        columnCells.forEach(cell => cell.classList.add('col-hover'));
      }
    });

    cellGrid.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('cell')) {
        const rowIndex = e.target.dataset.rowIndex;
        const colIndex = e.target.dataset.colIndex;

        // Remove highlight from TLD row
        const tldRow = tldColumn.querySelector(`.tld-row[data-row-index="${rowIndex}"]`);
        if (tldRow) {
          tldRow.classList.remove('row-hover');
        }

        // Remove highlight from cell row
        const cellRow = cellGrid.querySelector(`.cell-row[data-row-index="${rowIndex}"]`);
        if (cellRow) {
          cellRow.classList.remove('row-hover');
        }

        // Remove highlight from weekday cell
        const weekdayCell = weekdayRow.querySelector(`.weekday-cell[data-col-index="${colIndex}"]`);
        if (weekdayCell) {
          weekdayCell.classList.remove('col-hover');
        }

        // Remove highlight from day cell
        const dayCell = dayRow.querySelector(`.day-cell[data-col-index="${colIndex}"]`);
        if (dayCell) {
          dayCell.classList.remove('col-hover');
        }

        // Remove highlight from calendar event column
        const calendarEventsRow = document.getElementById('calendarEventsRow');
        if (calendarEventsRow) {
          const eventColumns = calendarEventsRow.children;
          if (eventColumns[colIndex]) {
            eventColumns[colIndex].classList.remove('col-hover');
          }
        }

        // Remove highlight from column cells
        const columnCells = cellGrid.querySelectorAll(`.cell[data-col-index="${colIndex}"]`);
        columnCells.forEach(cell => cell.classList.remove('col-hover'));
      }
    });
  }

  // Setup column header hover (for day-cell and weekday-cell in header)
  setupColumnHeaderHover() {
    const dayRow = document.getElementById('dayRow');
    const weekdayRow = document.getElementById('weekdayRow');
    const calendarEventsRow = document.getElementById('calendarEventsRow');
    const cellGrid = document.getElementById('cellGrid');

    // Helper function to highlight column
    const highlightColumn = (colIndex) => {
      // Highlight the weekday cell
      const weekdayCell = weekdayRow.querySelector(`.weekday-cell[data-col-index="${colIndex}"]`);
      if (weekdayCell) {
        weekdayCell.classList.add('col-hover');
      }

      // Highlight the day cell
      const dayCell = dayRow.querySelector(`.day-cell[data-col-index="${colIndex}"]`);
      if (dayCell) {
        dayCell.classList.add('col-hover');
      }

      // Highlight the calendar event column
      if (calendarEventsRow) {
        const eventColumns = calendarEventsRow.children;
        if (eventColumns[colIndex]) {
          eventColumns[colIndex].classList.add('col-hover');
        }
      }

      // Highlight all cells in the column
      const columnCells = cellGrid.querySelectorAll(`.cell[data-col-index="${colIndex}"]`);
      columnCells.forEach(cell => cell.classList.add('col-hover'));
    };

    // Helper function to remove column highlight
    const removeColumnHighlight = (colIndex) => {
      // Remove highlight from weekday cell
      const weekdayCell = weekdayRow.querySelector(`.weekday-cell[data-col-index="${colIndex}"]`);
      if (weekdayCell) {
        weekdayCell.classList.remove('col-hover');
      }

      // Remove highlight from day cell
      const dayCell = dayRow.querySelector(`.day-cell[data-col-index="${colIndex}"]`);
      if (dayCell) {
        dayCell.classList.remove('col-hover');
      }

      // Remove highlight from calendar event column
      if (calendarEventsRow) {
        const eventColumns = calendarEventsRow.children;
        if (eventColumns[colIndex]) {
          eventColumns[colIndex].classList.remove('col-hover');
        }
      }

      // Remove highlight from column cells
      const columnCells = cellGrid.querySelectorAll(`.cell[data-col-index="${colIndex}"]`);
      columnCells.forEach(cell => cell.classList.remove('col-hover'));
    };

    // Day cell hover
    dayRow.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('day-cell')) {
        const colIndex = e.target.dataset.colIndex;
        if (colIndex !== undefined) {
          highlightColumn(colIndex);
        }
      }
    });

    dayRow.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('day-cell')) {
        const colIndex = e.target.dataset.colIndex;
        if (colIndex !== undefined) {
          removeColumnHighlight(colIndex);
        }
      }
    });

    // Weekday cell hover
    weekdayRow.addEventListener('mouseover', (e) => {
      if (e.target.classList.contains('weekday-cell')) {
        const colIndex = e.target.dataset.colIndex;
        if (colIndex !== undefined) {
          highlightColumn(colIndex);
        }
      }
    });

    weekdayRow.addEventListener('mouseout', (e) => {
      if (e.target.classList.contains('weekday-cell')) {
        const colIndex = e.target.dataset.colIndex;
        if (colIndex !== undefined) {
          removeColumnHighlight(colIndex);
        }
      }
    });

    // Hour cell hover (for hourly view)
    // Need to check both target and closest parent since hour cells contain child divs
    dayRow.addEventListener('mouseover', (e) => {
      const hourCell = e.target.classList.contains('hour-cell') ? e.target : e.target.closest('.hour-cell');
      if (hourCell) {
        const colIndex = hourCell.dataset.colIndex;
        if (colIndex !== undefined) {
          highlightColumn(colIndex);
        }
      }
    });

    dayRow.addEventListener('mouseout', (e) => {
      const hourCell = e.target.classList.contains('hour-cell') ? e.target : e.target.closest('.hour-cell');
      if (hourCell) {
        const colIndex = hourCell.dataset.colIndex;
        if (colIndex !== undefined) {
          removeColumnHighlight(colIndex);
        }
      }
    });

    // Calendar event column hover (works for both day and hour views)
    if (calendarEventsRow) {
      calendarEventsRow.addEventListener('mouseover', (e) => {
        const eventColumn = e.target.classList.contains('calendar-event-column') ? e.target : e.target.closest('.calendar-event-column');
        if (eventColumn) {
          // Find the column index by getting the index of this element among its siblings
          const colIndex = Array.from(calendarEventsRow.children).indexOf(eventColumn);
          if (colIndex !== -1) {
            highlightColumn(colIndex);
          }
        }
      });

      calendarEventsRow.addEventListener('mouseout', (e) => {
        const eventColumn = e.target.classList.contains('calendar-event-column') ? e.target : e.target.closest('.calendar-event-column');
        if (eventColumn) {
          // Find the column index by getting the index of this element among its siblings
          const colIndex = Array.from(calendarEventsRow.children).indexOf(eventColumn);
          if (colIndex !== -1) {
            removeColumnHighlight(colIndex);
          }
        }
      });
    }
  }

  // Setup cell click to expand and show URLs
  setupCellClick() {
    const cellGrid = document.getElementById('cellGrid');
    const expandedView = document.getElementById('expandedView');
    const closeBtn = document.getElementById('closeExpanded');

    // Click on cell to expand
    cellGrid.addEventListener('click', (e) => {
      if (e.target.classList.contains('cell') && !e.target.classList.contains('empty')) {
        const domain = e.target.dataset.domain;
        const date = e.target.dataset.date;
        const count = parseInt(e.target.dataset.count);

        // If clicking the same cell, close it
        if (this.selectedCell === e.target) {
          this.closeExpandedView();
          return;
        }

        // Remove previous selection
        if (this.selectedCell) {
          this.selectedCell.classList.remove('selected');
        }

        // Mark as selected
        e.target.classList.add('selected');
        this.selectedCell = e.target;

        // Show expanded view based on view mode
        if (this.viewMode === 'hour') {
          // In hour view, date is actually hourStr, show URLs for specific domain and hour
          this.showDomainHourView(domain, date, count);
        } else {
          // In day view, show URLs for specific domain and date
          this.showExpandedView(domain, date, count);
        }
      }
    });

    // Close button
    closeBtn.addEventListener('click', () => {
      this.closeExpandedView();
    });

    // Keyboard navigation (arrow keys)
    document.addEventListener('keydown', (e) => {
      if (expandedView.style.display !== 'block') return;

      const domain = this.selectedCell?.dataset.domain;
      const date = this.selectedCell?.dataset.date;

      if (!date) return;

      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (this.viewMode === 'hour') {
          this.navigateDomainHour(domain, date, -1);
        } else {
          this.navigateDay(domain, date, -1);
        }
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (this.viewMode === 'hour') {
          this.navigateDomainHour(domain, date, 1);
        } else {
          this.navigateDay(domain, date, 1);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        this.closeExpandedView();
      }
    });

    // Horizontal scroll/swipe navigation
    let scrollTimeout = null;
    expandedView.addEventListener('wheel', (e) => {
      if (expandedView.style.display !== 'block') return;

      const domain = this.selectedCell?.dataset.domain;
      const date = this.selectedCell?.dataset.date;

      if (!date) return;

      // Detect horizontal scroll (deltaX for horizontal, deltaY for vertical)
      const isHorizontalScroll = Math.abs(e.deltaX) > Math.abs(e.deltaY);

      if (isHorizontalScroll && Math.abs(e.deltaX) > 10) {
        e.preventDefault();

        // Debounce rapid scroll events
        if (scrollTimeout) return;

        scrollTimeout = setTimeout(() => {
          scrollTimeout = null;
        }, 200);

        // Scroll right = next, scroll left = previous
        if (e.deltaX > 0) {
          if (this.viewMode === 'hour') {
            this.navigateDomainHour(domain, date, 1);
          } else {
            this.navigateDay(domain, date, 1);
          }
        } else {
          if (this.viewMode === 'hour') {
            this.navigateDomainHour(domain, date, -1);
          } else {
            this.navigateDay(domain, date, -1);
          }
        }
      }
    }, { passive: false });
  }

  // Show full history view with all URLs from all domains
  showFullHistory() {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');

    // Hide calendar section (not used in full history view)
    const calendarSection = document.getElementById('calendarSection');
    if (calendarSection) {
      calendarSection.style.display = 'none';
    }

    // Set view type
    this.expandedViewType = 'full';
    this.currentDomain = null;

    // Calculate total visits across all domains
    let totalVisits = 0;
    Object.values(this.historyData).forEach(domainData => {
      Object.values(domainData.days).forEach(day => {
        totalVisits += day.count;
      });
    });

    // Set title
    expandedTitle.textContent = `Full History (${totalVisits} total)`;

    // Remove navigation and delete button if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) navContainer.remove();
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) deleteBtn.remove();

    // Collect all URLs from all domains with their dates
    const allUrls = [];
    Object.keys(this.historyData).forEach(domain => {
      Object.keys(this.historyData[domain].days).forEach(dateStr => {
        const dayData = this.historyData[domain].days[dateStr];
        dayData.urls.forEach(urlData => {
          allUrls.push({
            ...urlData,
            domain: domain,
            date: dateStr
          });
        });
      });
    });

    // Sort based on current sort mode
    if (this.sortMode === 'popular') {
      // Most Popular: Sort by visit count (descending)
      allUrls.sort((a, b) => b.visitCount - a.visitCount);
    } else if (this.sortMode === 'alphabetical') {
      // Alphabetical: Sort by domain, then by URL
      allUrls.sort((a, b) => {
        const domainCompare = a.domain.localeCompare(b.domain);
        if (domainCompare !== 0) return domainCompare;
        return a.url.localeCompare(b.url);
      });
    } else {
      // Most Recent (default): Sort by most recent visit
      allUrls.sort((a, b) => b.lastVisit - a.lastVisit);
    }

    // Store URLs and render with pagination
    this.expandedUrls = allUrls;
    this.renderUrlList();

    this.showExpandedViewAnimated();
  }

  // Show domain view with all URLs grouped by date
  showDomainView(domain) {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');
    const expandedHeader = document.querySelector('.expanded-header');

    // Hide calendar section (not used in domain view)
    const calendarSection = document.getElementById('calendarSection');
    if (calendarSection) {
      calendarSection.style.display = 'none';
    }

    // Set view type
    this.expandedViewType = 'domain';
    this.currentDomain = domain;

    // Calculate total visits
    const domainData = this.historyData[domain];
    let totalVisits = 0;
    Object.values(domainData.days).forEach(day => {
      totalVisits += day.count;
    });

    // Set title (no navigation buttons for domain view)
    expandedTitle.textContent = `${domain} (${totalVisits} total visit${totalVisits !== 1 ? 's' : ''})`;

    // Remove navigation if it exists
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) {
      navContainer.remove();
    }

    // Add delete domain button if not exists
    let deleteBtn = document.getElementById('deleteDomain');
    if (!deleteBtn) {
      deleteBtn = document.createElement('button');
      deleteBtn.id = 'deleteDomain';
      deleteBtn.className = 'delete-domain-btn';
      deleteBtn.textContent = 'delete all';
      deleteBtn.title = 'Delete all history for this domain';

      // Insert before close button
      const closeBtn = document.getElementById('closeExpanded');
      expandedHeader.insertBefore(deleteBtn, closeBtn);
    }

    // Update delete button click handler
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    newDeleteBtn.addEventListener('click', () => this.deleteDomain(domain));

    // Collect all URLs for this domain
    const allUrls = [];
    Object.keys(domainData.days).forEach(dateStr => {
      const dayData = domainData.days[dateStr];
      dayData.urls.forEach(urlData => {
        allUrls.push({
          ...urlData,
          domain: domain,
          date: dateStr
        });
      });
    });

    // Sort by most recent first
    allUrls.sort((a, b) => b.lastVisit - a.lastVisit);

    // Store URLs and render with pagination
    this.expandedUrls = allUrls;
    this.renderUrlList();

    this.showExpandedViewAnimated();
  }

  // Show expanded view with URLs
  showExpandedView(domain, date, count) {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');

    // Set view type
    this.expandedViewType = 'cell';
    this.currentDomain = null;

    // Remove delete domain button if it exists
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) {
      deleteBtn.remove();
    }

    // Format date nicely
    const dateObj = new Date(date + 'T00:00:00');
    const formattedDate = dateObj.toLocaleDateString('en-US', {
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    });

    // Set title and date
    expandedTitle.textContent = `${domain} (${count} visit${count !== 1 ? 's' : ''})`;

    // Update or create navigation controls
    let navContainer = document.getElementById('expandedNav');
    if (!navContainer) {
      navContainer = document.createElement('div');
      navContainer.id = 'expandedNav';
      navContainer.className = 'expanded-nav';

      const dateElement = document.createElement('span');
      dateElement.id = 'expandedDate';
      dateElement.className = 'expanded-date';

      const prevBtn = document.createElement('button');
      prevBtn.id = 'prevDay';
      prevBtn.className = 'nav-btn';
      prevBtn.innerHTML = 'â€¹';
      prevBtn.title = 'Previous day';

      const nextBtn = document.createElement('button');
      nextBtn.id = 'nextDay';
      nextBtn.className = 'nav-btn';
      nextBtn.innerHTML = 'â€º';
      nextBtn.title = 'Next day';

      navContainer.appendChild(prevBtn);
      navContainer.appendChild(dateElement);
      navContainer.appendChild(nextBtn);

      document.querySelector('.expanded-header').insertBefore(
        navContainer,
        document.getElementById('closeExpanded')
      );
    }

    // Update click handlers with current date
    const prevBtn = document.getElementById('prevDay');
    const nextBtn = document.getElementById('nextDay');

    // Remove old listeners by cloning
    const newPrevBtn = prevBtn.cloneNode(true);
    const newNextBtn = nextBtn.cloneNode(true);
    prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);

    // Add new listeners with current date
    newPrevBtn.addEventListener('click', () => this.navigateDay(domain, date, -1));
    newNextBtn.addEventListener('click', () => this.navigateDay(domain, date, 1));

    // Update date text
    document.getElementById('expandedDate').textContent = formattedDate;

    // Update button states
    this.updateNavButtons(domain, date);

    // Get URLs for this cell
    const dayData = this.historyData[domain].days[date];
    if (!dayData || !dayData.urls) {
      urlList.innerHTML = '<div style="padding: 16px; color: #999;">No URLs found</div>';
      this.showExpandedViewAnimated();
      return;
    }

    // Sort URLs chronologically (most recent first)
    const urls = [...dayData.urls].sort((a, b) => b.lastVisit - a.lastVisit);

    // Add domain and date to each URL
    const urlsWithContext = urls.map(urlData => ({
      ...urlData,
      domain: domain,
      date: date
    }));

    // Store URLs and render with pagination
    this.expandedUrls = urlsWithContext;
    this.renderUrlList();

    // Render calendar events for this date
    this.renderCalendarEventsForDate(date);

    this.showExpandedViewAnimated();
  }

  // Get the display name for the current view type
  getViewName() {
    switch (this.expandedViewType) {
      case 'full':
      case 'recent':
        return 'Full History';
      case 'bookmarks':
        return 'Bookmarks';
      case 'closed':
        return 'Recently Closed';
      case 'domain':
        return this.currentDomain || 'Domain';
      case 'cell':
        return this.selectedCell?.dataset.domain || 'History';
      default:
        return 'History';
    }
  }

  // Render URL list with pagination
  renderUrlList() {
    const urlList = document.getElementById('urlList');
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');

    // Filter URLs based on search filter
    let filteredUrls = this.expandedUrls;
    if (this.searchFilter) {
      const filterLower = this.searchFilter.toLowerCase();
      filteredUrls = this.expandedUrls.filter(urlData => {
        const domain = urlData.domain?.toLowerCase() || '';
        const url = urlData.url?.toLowerCase() || '';
        const title = urlData.title?.toLowerCase() || '';
        return domain.includes(filterLower) || url.includes(filterLower) || title.includes(filterLower);
      });
    }

    // Update title with filtered count
    if (this.searchFilter && filteredUrls.length !== this.expandedUrls.length) {
      const viewName = this.getViewName();
      expandedTitle.textContent = `${viewName} (${filteredUrls.length} found)`;
    } else {
      const viewName = this.getViewName();
      expandedTitle.textContent = `${viewName} (${this.expandedUrls.length} total)`;
    }

    // Get current page for this view type
    const currentPage = this.viewPagination[this.expandedViewType] || 1;

    // Calculate pagination
    const totalItems = filteredUrls.length;
    const totalPages = Math.ceil(totalItems / this.itemsPerPage);
    const startIndex = (currentPage - 1) * this.itemsPerPage;
    const endIndex = Math.min(startIndex + this.itemsPerPage, totalItems);

    // Clear list
    urlList.innerHTML = '';

    // Render items for current page with grouping headers
    let currentGroup = null;
    for (let i = startIndex; i < endIndex; i++) {
      const urlData = filteredUrls[i];

      // Determine group based on view type and sort mode
      let groupKey = null;
      let groupLabel = null;

      if (this.expandedViewType === 'bookmarks') {
        // Bookmarks: Always group by folder
        groupKey = urlData.folder || 'Root';
        groupLabel = groupKey;
      } else if (this.expandedViewType === 'closed' || this.expandedViewType === 'full' || this.expandedViewType === 'recent') {
        // All and Closed: Only show date headers in "Most Recent" mode
        if (this.sortMode === 'recent') {
          if (this.expandedViewType === 'closed') {
            // Group by date closed
            groupKey = this.formatDate(new Date(urlData.closedAt));
            groupLabel = this.formatDateHeader(groupKey);
          } else {
            // Group by date visited
            groupKey = this.formatDate(new Date(urlData.lastVisit));
            groupLabel = this.formatDateHeader(groupKey);
          }
        }
        // For 'popular' and 'alphabetical' modes, don't show any headers
      }

      // Add group header if group changed
      if (groupKey && groupKey !== currentGroup) {
        currentGroup = groupKey;
        const groupHeader = document.createElement('div');
        groupHeader.className = 'date-group-header';
        groupHeader.textContent = groupLabel;
        urlList.appendChild(groupHeader);
      }

      const urlItem = this.createUrlItem(urlData, urlData.domain, urlData.date);
      urlList.appendChild(urlItem);
    }

    // Add extra whitespace if fewer than 20 items to ensure expanded view can open fully
    const itemsOnPage = endIndex - startIndex;
    if (itemsOnPage < 20) {
      const spacer = document.createElement('div');
      spacer.style.minHeight = '400px'; // Ensure enough space for resizing
      urlList.appendChild(spacer);
    }

    // Update or create pagination controls
    this.renderPaginationControls(totalPages, totalItems, currentPage);

    // Force recalculation of scroll area to handle zoom/text wrapping
    // This ensures the browser recognizes the full content height
    requestAnimationFrame(() => {
      expandedView.style.overflow = 'hidden';
      expandedView.offsetHeight; // Force reflow
      expandedView.style.overflow = 'auto';
    });
  }

  // Render pagination controls
  renderPaginationControls(totalPages, totalItems, currentPage) {
    const expandedView = document.getElementById('expandedView');
    const urlList = document.getElementById('urlList');

    // Remove existing pagination if present
    let pagination = document.getElementById('pagination');
    if (pagination) {
      pagination.remove();
    }

    // Only show pagination if there's more than one page
    if (totalPages <= 1) return;

    // Create pagination container
    pagination = document.createElement('div');
    pagination.id = 'pagination';
    pagination.className = 'pagination';

    // Previous button
    const prevBtn = document.createElement('button');
    prevBtn.className = 'pagination-btn';
    prevBtn.textContent = 'â€¹ Previous';
    prevBtn.disabled = currentPage === 1;
    prevBtn.addEventListener('click', () => {
      if (currentPage > 1) {
        this.viewPagination[this.expandedViewType]--;
        this.renderUrlList();
        expandedView.scrollTop = 0;
      }
    });

    // Page info
    const pageInfo = document.createElement('span');
    pageInfo.className = 'pagination-info';
    const start = (currentPage - 1) * this.itemsPerPage + 1;
    const end = Math.min(currentPage * this.itemsPerPage, totalItems);
    pageInfo.textContent = `${start}-${end} of ${totalItems}`;

    // Next button
    const nextBtn = document.createElement('button');
    nextBtn.className = 'pagination-btn';
    nextBtn.textContent = 'Next â€º';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.addEventListener('click', () => {
      if (currentPage < totalPages) {
        this.viewPagination[this.expandedViewType]++;
        this.renderUrlList();
        expandedView.scrollTop = 0;
      }
    });

    pagination.appendChild(prevBtn);
    pagination.appendChild(pageInfo);
    pagination.appendChild(nextBtn);

    urlList.appendChild(pagination);
  }

  // Create a URL item element
  createUrlItem(urlData, domain, date) {
    const urlItem = document.createElement('div');
    urlItem.className = 'url-item';

    // Left side: count + actions
    const leftDiv = document.createElement('div');
    leftDiv.className = 'url-item-left';

    const countSpan = document.createElement('span');
    countSpan.className = 'url-item-count';
    countSpan.textContent = `${urlData.visitCount}Ã—`;

    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'url-item-actions';

    // For bookmarks view: Show "Manage" button instead of delete
    if (this.expandedViewType === 'bookmarks') {
      const manageBtn = document.createElement('button');
      manageBtn.className = 'icon-btn manage';
      manageBtn.textContent = 'âš™ï¸';
      manageBtn.title = 'Manage bookmark in Chrome';
      manageBtn.addEventListener('click', () => {
        // Open Chrome's bookmark manager to the specific folder
        const folderId = urlData.folderId || '';
        const bookmarkUrl = folderId ? `chrome://bookmarks/?id=${folderId}` : 'chrome://bookmarks/';
        chrome.tabs.create({ url: bookmarkUrl });
      });
      actionsDiv.appendChild(manageBtn);
    } else {
      // For other views: Show delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'icon-btn delete';
      deleteBtn.textContent = 'ðŸ—‘ï¸';
      deleteBtn.title = 'Delete from history';
      deleteBtn.addEventListener('click', (e) => {
        // Find the parent url-item element
        const urlItem = e.target.closest('.url-item');
        // Trigger delete animation, then delete
        this.deleteUrlWithAnimation(urlItem, urlData.url, domain, date);
      });
      actionsDiv.appendChild(deleteBtn);
    }

    const bookmarkBtn = document.createElement('button');
    bookmarkBtn.className = 'icon-btn bookmark';
    bookmarkBtn.textContent = 'â­';
    bookmarkBtn.title = 'Toggle bookmark';
    bookmarkBtn.addEventListener('click', () => this.toggleBookmark(urlData.url, urlData.title, bookmarkBtn));

    // Check if URL is already bookmarked
    this.checkBookmarkStatus(urlData.url, bookmarkBtn);

    actionsDiv.appendChild(bookmarkBtn);

    leftDiv.appendChild(countSpan);
    leftDiv.appendChild(actionsDiv);

    // Right side: Favicon + URL as clickable link
    const rightDiv = document.createElement('div');
    rightDiv.className = 'url-item-right';

    // Add favicon
    const favicon = document.createElement('img');
    favicon.className = 'url-favicon';
    favicon.src = `https://www.google.com/s2/favicons?domain=${urlData.url}&sz=16`;
    favicon.alt = '';
    favicon.width = 16;
    favicon.height = 16;

    const urlLink = document.createElement('a');
    urlLink.href = urlData.url;

    // Truncate URLs longer than 400 characters
    if (urlData.url.length > 400) {
      urlLink.textContent = urlData.url.substring(0, 400) + '...';
      urlLink.title = urlData.url; // Show full URL on hover
    } else {
      urlLink.textContent = urlData.url;
    }

    urlLink.target = '_blank';
    urlLink.rel = 'noopener noreferrer';

    // Add timestamp
    const timestamp = document.createElement('span');
    timestamp.className = 'url-timestamp';
    const lastVisitDate = new Date(urlData.lastVisit);

    // Format as HH:MM:SS
    const hours = String(lastVisitDate.getHours()).padStart(2, '0');
    const minutes = String(lastVisitDate.getMinutes()).padStart(2, '0');
    const seconds = String(lastVisitDate.getSeconds()).padStart(2, '0');
    const timeText = `${hours}:${minutes}:${seconds}`;

    timestamp.textContent = timeText;
    timestamp.title = lastVisitDate.toLocaleString();

    rightDiv.appendChild(favicon);
    rightDiv.appendChild(urlLink);
    rightDiv.appendChild(timestamp);

    urlItem.appendChild(leftDiv);
    urlItem.appendChild(rightDiv);

    // Add hover preview functionality to the URL link only
    this.attachUrlPreview(urlLink, urlData);

    return urlItem;
  }

  // Attach URL preview tooltip to a URL item
  attachUrlPreview(urlItem, urlData) {
    const previewTooltip = document.getElementById('urlPreviewTooltip');
    let hoverTimeout;

    urlItem.addEventListener('mouseenter', (e) => {
      // Delay showing the preview slightly
      hoverTimeout = setTimeout(() => {
        this.showUrlPreview(urlData, e);
      }, 300);
    });

    urlItem.addEventListener('mouseleave', () => {
      clearTimeout(hoverTimeout);
      previewTooltip.classList.remove('visible');
    });

    urlItem.addEventListener('mousemove', (e) => {
      if (previewTooltip.classList.contains('visible')) {
        this.positionUrlPreview(e);
      }
    });
  }

  // Show URL preview tooltip
  async showUrlPreview(urlData, event) {
    const previewTooltip = document.getElementById('urlPreviewTooltip');

    // Format last visit date
    const lastVisitDate = new Date(urlData.lastVisit);
    const now = new Date();
    const diffMs = now - lastVisitDate;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    let timeAgo;
    if (diffMins < 1) {
      timeAgo = 'Just now';
    } else if (diffMins < 60) {
      timeAgo = `${diffMins} min${diffMins !== 1 ? 's' : ''} ago`;
    } else if (diffHours < 24) {
      timeAgo = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
    } else if (diffDays < 30) {
      timeAgo = `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
    } else {
      timeAgo = lastVisitDate.toLocaleDateString();
    }

    // Determine if this is from recently closed view
    const isClosedTab = this.expandedViewType === 'closed';
    const timeLabel = isClosedTab ? 'Closed' : 'Last visited';

    // Show loading state first
    previewTooltip.innerHTML = `
      <div class="url-preview-content">
        <div class="url-preview-header">
          <img src="https://www.google.com/s2/favicons?domain=${urlData.url}&sz=32"
               class="url-preview-favicon"
               width="32"
               height="32"
               alt="">
          <div class="url-preview-title">${urlData.title || 'Untitled'}</div>
        </div>
        <div class="url-preview-url">${urlData.url}</div>
        <div class="url-preview-meta">
          ${isClosedTab ? '' : `<div class="url-preview-meta-item">
            <span class="url-preview-meta-label">Visits</span>
            <span class="url-preview-meta-value">${urlData.visitCount}</span>
          </div>`}
          <div class="url-preview-meta-item">
            <span class="url-preview-meta-label">${timeLabel}</span>
            <span class="url-preview-meta-value">${timeAgo} (${lastVisitDate.toLocaleString('en-US', {
              month: 'short',
              day: 'numeric',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            })})</span>
          </div>
        </div>
      </div>
    `;

    this.positionUrlPreview(event);
    previewTooltip.classList.add('visible');

    // Fetch OG metadata (title and description only)
    const ogData = await this.fetchOpenGraphData(urlData.url);

    // Update with OG data if available
    const descriptionHtml = ogData.description ? `
      <div class="url-preview-description">${ogData.description}</div>
    ` : '';

    previewTooltip.innerHTML = `
      <div class="url-preview-content">
        <div class="url-preview-header">
          <img src="https://www.google.com/s2/favicons?domain=${urlData.url}&sz=32"
               class="url-preview-favicon"
               width="32"
               height="32"
               alt="">
          <div class="url-preview-title">${ogData.title || urlData.title || 'Untitled'}</div>
        </div>
        ${descriptionHtml}
        <div class="url-preview-url">${urlData.url}</div>
        <div class="url-preview-meta">
          ${isClosedTab ? '' : `<div class="url-preview-meta-item">
            <span class="url-preview-meta-label">Visits</span>
            <span class="url-preview-meta-value">${urlData.visitCount}</span>
          </div>`}
          <div class="url-preview-meta-item">
            <span class="url-preview-meta-label">${timeLabel}</span>
            <span class="url-preview-meta-value">${timeAgo} (${lastVisitDate.toLocaleString('en-US', {
              month: 'short',
              day: 'numeric',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit'
            })})</span>
          </div>
        </div>
      </div>
    `;

    this.positionUrlPreview(event);
  }

  // Position the URL preview tooltip
  positionUrlPreview(event) {
    const previewTooltip = document.getElementById('urlPreviewTooltip');
    const offsetX = 15;
    const offsetY = 15;

    let x = event.clientX + offsetX;
    let y = event.clientY + offsetY;

    // Get tooltip dimensions
    const rect = previewTooltip.getBoundingClientRect();

    // Prevent tooltip from going off screen
    if (x + rect.width > window.innerWidth) {
      x = event.clientX - rect.width - offsetX;
    }

    if (y + rect.height > window.innerHeight) {
      y = event.clientY - rect.height - offsetY;
    }

    previewTooltip.style.left = `${x}px`;
    previewTooltip.style.top = `${y}px`;
  }

  // Fetch Open Graph metadata (title and description only, no images)
  async fetchOpenGraphData(url) {
    // Check cache first
    if (this.ogCache.has(url)) {
      return this.ogCache.get(url);
    }

    // Default empty data
    const defaultData = {
      title: null,
      description: null
    };

    try {
      // Fetch the HTML page
      const response = await fetch(url, {
        method: 'GET',
        mode: 'cors',
        cache: 'default'
      });

      if (!response.ok) {
        this.ogCache.set(url, defaultData);
        return defaultData;
      }

      const html = await response.text();

      // Parse OG meta tags
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      const ogData = {
        title: this.getMetaContent(doc, 'og:title') || this.getMetaContent(doc, 'twitter:title'),
        description: this.getMetaContent(doc, 'og:description') || this.getMetaContent(doc, 'twitter:description') || this.getMetaContent(doc, 'description')
      };

      // Cache the result
      this.ogCache.set(url, ogData);

      return ogData;
    } catch (error) {
      // CORS blocked or other error - cache empty data
      this.ogCache.set(url, defaultData);
      return defaultData;
    }
  }

  // Helper to extract meta tag content
  getMetaContent(doc, property) {
    const meta = doc.querySelector(`meta[property="${property}"]`) ||
                 doc.querySelector(`meta[name="${property}"]`);
    return meta ? meta.getAttribute('content') : null;
  }

  // Update main section to account for expanded view height
  updateExpandedViewPadding() {
    requestAnimationFrame(() => {
      const expandedView = document.getElementById('expandedView');
      const mainSection = document.querySelector('.main-section');

      if (expandedView.style.display === 'block') {
        const expandedHeight = expandedView.offsetHeight;
        mainSection.style.paddingBottom = `${expandedHeight}px`;
      } else {
        mainSection.style.paddingBottom = '0';
      }
    });
  }

  // Close expanded view with animation
  closeExpandedView() {
    const expandedView = document.getElementById('expandedView');

    // Add slide-out animation
    expandedView.classList.add('slide-out');

    // Wait for animation to complete before hiding
    setTimeout(() => {
      expandedView.style.display = 'none';
      expandedView.classList.remove('slide-out');
      this.updateExpandedViewPadding();
    }, 200); // Match slide-out duration

    if (this.selectedCell) {
      this.selectedCell.classList.remove('selected');
      this.selectedCell = null;
    }

    this.expandedViewType = null;
    this.currentDomain = null;
    this.currentDate = null;
    this.currentHour = null;
  }

  // Show expanded view with animation
  showExpandedViewAnimated() {
    const expandedView = document.getElementById('expandedView');

    // Check if already open - if so, skip animation
    const wasAlreadyOpen = expandedView.style.display === 'block';

    // Set display first
    expandedView.style.display = 'block';

    // Only animate if it wasn't already open
    if (!wasAlreadyOpen) {
      // Force reflow to ensure display change is applied
      expandedView.offsetHeight;

      // Add slide-in animation
      expandedView.classList.add('slide-in');

      // Remove animation class after it completes
      setTimeout(() => {
        expandedView.classList.remove('slide-in');
      }, 250); // Match slide-in duration
    }

    this.updateExpandedViewPadding();
  }

  // Navigate to previous or next day for the same domain
  navigateDay(domain, currentDate, direction) {
    // Get all dates for this domain sorted chronologically
    const domainDates = Object.keys(this.historyData[domain].days).sort();

    // Find current date index
    const currentIndex = domainDates.indexOf(currentDate);

    if (currentIndex === -1) return;

    // Get next/prev date
    const newIndex = currentIndex + direction;

    if (newIndex >= 0 && newIndex < domainDates.length) {
      const newDate = domainDates[newIndex];
      const dayData = this.historyData[domain].days[newDate];

      // Update selected cell
      if (this.selectedCell) {
        this.selectedCell.classList.remove('selected');
      }

      // Find and select the new cell (if visible)
      const colIndex = this.dates.indexOf(newDate);
      const rowIndex = this.sortedDomains.indexOf(domain);
      const newCell = document.querySelector(`.cell[data-row-index="${rowIndex}"][data-col-index="${colIndex}"]`);

      if (newCell) {
        newCell.classList.add('selected');
        this.selectedCell = newCell;
      } else {
        this.selectedCell = null;
      }

      // Show expanded view for new date
      this.showExpandedView(domain, newDate, dayData.count);
    }
  }

  // Navigate to previous or next hour for the same domain (for hourly view)
  navigateDomainHour(domain, currentHourStr, direction) {
    // Get all hours where this domain has data
    const domainHours = [];
    if (this.hourlyData[domain]) {
      for (const hourStr of this.hours) {
        if (this.hourlyData[domain][hourStr] && this.hourlyData[domain][hourStr].count > 0) {
          domainHours.push(hourStr);
        }
      }
    }

    if (domainHours.length === 0) return;

    // Find current hour index
    const currentIndex = domainHours.indexOf(currentHourStr);

    if (currentIndex === -1) return;

    // Get next/prev hour
    const newIndex = currentIndex + direction;

    if (newIndex >= 0 && newIndex < domainHours.length) {
      const newHourStr = domainHours[newIndex];
      const hourData = this.hourlyData[domain][newHourStr];

      // Update selected cell
      if (this.selectedCell) {
        this.selectedCell.classList.remove('selected');
      }

      // Find the cell for this domain and hour
      const colIndex = this.hours.indexOf(newHourStr);
      const rowIndex = this.sortedDomains.indexOf(domain);
      const newCell = document.querySelector(`.cell[data-row-index="${rowIndex}"][data-col-index="${colIndex}"]`);

      if (newCell) {
        newCell.classList.add('selected');
        this.selectedCell = newCell;
      } else {
        this.selectedCell = null;
      }

      // Show expanded view for new domain-hour
      this.showDomainHourView(domain, newHourStr, hourData.count);
    }
  }

  // Update navigation button states based on available data
  updateNavButtons(domain, currentDate) {
    const prevBtn = document.getElementById('prevDay');
    const nextBtn = document.getElementById('nextDay');

    if (!prevBtn || !nextBtn) return;

    // Get all dates for this domain sorted chronologically
    const domainDates = Object.keys(this.historyData[domain].days).sort();

    // Find current date index
    const currentIndex = domainDates.indexOf(currentDate);

    // Disable buttons at boundaries
    prevBtn.disabled = currentIndex <= 0;
    nextBtn.disabled = currentIndex >= domainDates.length - 1;
  }

  // Delete URL with animation
  deleteUrlWithAnimation(urlItemElement, url, domain, date) {
    if (urlItemElement) {
      // Add deleting class to trigger animation
      urlItemElement.classList.add('deleting');

      // Wait for animation to complete before deleting
      setTimeout(() => {
        this.deleteUrl(url, domain, date);
      }, 250); // Match slideOutLeft duration
    } else {
      // No element to animate, delete immediately
      this.deleteUrl(url, domain, date);
    }
  }

  // Delete URL from history
  async deleteUrl(url, domain, date) {
    // Delete from Chrome history
    chrome.history.deleteUrl({ url: url }, async () => {

      // If in closed tabs view, also remove from closed tabs storage
      if (this.expandedViewType === 'closed') {
        const result = await chrome.storage.local.get(['closedTabs']);
        const closedTabs = result.closedTabs || [];
        const updatedClosedTabs = closedTabs.filter(tab => tab.url !== url);
        await chrome.storage.local.set({ closedTabs: updatedClosedTabs });
      }

      // Update local data based on view mode
      if (this.viewMode === 'hour' && date.includes('T')) {
        // In hour view, date is hourStr - update hourly data
        if (this.hourlyData[domain] && this.hourlyData[domain][date]) {
          const hourData = this.hourlyData[domain][date];
          const urlIndex = hourData.urls.findIndex(u => u.url === url);

          if (urlIndex !== -1) {
            hourData.urls.splice(urlIndex, 1);
            hourData.count--;

            // If no more URLs for this hour, remove the hour
            if (hourData.urls.length === 0) {
              delete this.hourlyData[domain][date];
            }

            // If domain has no more hours, remove domain from hourly data
            if (Object.keys(this.hourlyData[domain]).length === 0) {
              delete this.hourlyData[domain];
            }
          }
        }

        // Also update daily data
        const dayStr = date.split('T')[0];
        const dayData = this.historyData[domain]?.days[dayStr];
        if (dayData) {
          const urlIndex = dayData.urls.findIndex(u => u.url === url);
          if (urlIndex !== -1) {
            dayData.urls.splice(urlIndex, 1);
            dayData.count--;

            if (dayData.urls.length === 0) {
              delete this.historyData[domain].days[dayStr];
            }
          }
        }
      } else {
        // In day view - update daily data only
        const dayData = this.historyData[domain]?.days[date];
        if (dayData) {
          const urlIndex = dayData.urls.findIndex(u => u.url === url);
          if (urlIndex !== -1) {
            dayData.urls.splice(urlIndex, 1);
            dayData.count--;

            if (dayData.urls.length === 0) {
              delete this.historyData[domain].days[date];
            }
          }
        }
      }

      // If domain has no more days, remove domain and close view
      if (this.historyData[domain] && Object.keys(this.historyData[domain].days).length === 0) {
        delete this.historyData[domain];
        // Re-sort based on view mode
        if (this.viewMode === 'hour') {
          this.sortedDomains = this.sortDomainsForHourView();
        } else {
          this.sortedDomains = this.getSortedDomains();
        }
        this.closeExpandedView();

        // Force complete re-render
        this.virtualState = {
          startRow: -1,
          endRow: -1,
          startCol: -1,
          endCol: -1,
          viewportHeight: 0,
          viewportWidth: 0
        };
        this.setupVirtualGrid();
      } else {
        // Refresh the appropriate view
        if (this.expandedViewType === 'domain') {
          this.showDomainView(domain);

          // Force complete re-render
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        } else if (this.expandedViewType === 'cell') {
          // Refresh cell view based on current view mode
          if (this.viewMode === 'hour') {
            // In hour view, date is actually hourStr
            if (this.hourlyData[domain] && this.hourlyData[domain][date]) {
              this.showDomainHourView(domain, date, this.hourlyData[domain][date].count);

              // Force complete re-render
              this.virtualState = {
                startRow: -1,
                endRow: -1,
                startCol: -1,
                endCol: -1,
                viewportHeight: 0,
                viewportWidth: 0
              };
              this.setupVirtualGrid();
            } else {
              // Hour is empty, close the view
              this.closeExpandedView();

              // Force complete re-render
              this.virtualState = {
                startRow: -1,
                endRow: -1,
                startCol: -1,
                endCol: -1,
                viewportHeight: 0,
                viewportWidth: 0
              };
              this.setupVirtualGrid();
            }
          } else {
            // In day view
            if (this.historyData[domain].days[date]) {
              this.showExpandedView(domain, date, this.historyData[domain].days[date].count);

              // Force complete re-render
              this.virtualState = {
                startRow: -1,
                endRow: -1,
                startCol: -1,
                endCol: -1,
                viewportHeight: 0,
                viewportWidth: 0
              };
              this.setupVirtualGrid();
            } else {
              // Day is empty, close the view
              this.closeExpandedView();

              // Force complete re-render
              this.virtualState = {
                startRow: -1,
                endRow: -1,
                startCol: -1,
                endCol: -1,
                viewportHeight: 0,
                viewportWidth: 0
              };
              this.setupVirtualGrid();
            }
          }
        } else if (this.expandedViewType === 'day') {
          // Refresh day view with updated data
          this.showDayExpandedView(this.currentDate);

          // Force complete re-render
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        } else if (this.expandedViewType === 'hour') {
          // Refresh hour view with updated data
          this.showHourExpandedView(this.currentHour);

          // Force complete re-render
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        } else if (this.expandedViewType === 'full' || this.expandedViewType === 'recent') {
          // Refresh "All" view
          this.showFullHistory();

          // Force complete re-render
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        } else if (this.expandedViewType === 'closed') {
          // Refresh "Closed" view
          this.showRecentlyClosed();

          // Force complete re-render
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        } else {
          // For any other view (bookmarks, etc), just refresh the grid
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        }
      }
      }
      }
    });
  }

  // Delete domain with animation
  deleteDomainWithAnimation(tldRowElement, domain) {
    if (tldRowElement) {
      // Add deleting class to trigger animation
      tldRowElement.classList.add('deleting');

      // Wait for animation to complete before deleting
      setTimeout(() => {
        this.deleteDomain(domain);
      }, 300); // Match shrinkRow duration
    } else {
      // No element to animate, delete immediately
      this.deleteDomain(domain);
    }
  }

  // Delete all history for a domain (alias for use in TLD row delete button)
  deleteDomainData(domain) {
    this.deleteDomain(domain);
  }

  // Delete all history for a domain
  async deleteDomain(domain) {
    if (!confirm(`Delete all history for ${domain}? This will remove all ${Object.keys(this.historyData[domain].days).length} days of history for this domain.`)) {
      return;
    }

    // Get all URLs for this domain
    const allUrls = [];
    Object.values(this.historyData[domain].days).forEach(dayData => {
      dayData.urls.forEach(urlData => {
        allUrls.push(urlData.url);
      });
    });

    // Delete each URL from Chrome history
    let deletedCount = 0;
    allUrls.forEach(url => {
      chrome.history.deleteUrl({ url: url }, () => {
        deletedCount++;

        // When all URLs are deleted, update UI
        if (deletedCount === allUrls.length) {

          // Remove domain from local data
          delete this.historyData[domain];

          // Also remove from hourly data if it exists
          if (this.hourlyData[domain]) {
            delete this.hourlyData[domain];
          }

          // Re-sort based on view mode
          if (this.viewMode === 'hour') {
            this.sortedDomains = this.sortDomainsForHourView();
          } else {
            this.sortedDomains = this.getSortedDomains();
          }

          // Close view and refresh grid
          this.closeExpandedView();

          // Force complete re-render by resetting virtual state
          this.virtualState = {
            startRow: -1,
            endRow: -1,
            startCol: -1,
            endCol: -1,
            viewportHeight: 0,
            viewportWidth: 0
          };
          this.setupVirtualGrid();
        }
      });
    });
  }

  // Check if URL is bookmarked and update button state
  checkBookmarkStatus(url, bookmarkBtn) {
    chrome.bookmarks.search({ url: url }, (results) => {
      if (results && results.length > 0) {
        bookmarkBtn.classList.add('saved');
        bookmarkBtn.dataset.bookmarkId = results[0].id;
      }
    });
  }

  // Toggle bookmark (add or remove)
  toggleBookmark(url, title, bookmarkBtn) {
    const bookmarkId = bookmarkBtn.dataset.bookmarkId;

    if (bookmarkId) {
      // Remove bookmark
      chrome.bookmarks.remove(bookmarkId, () => {
        bookmarkBtn.classList.remove('saved');
        delete bookmarkBtn.dataset.bookmarkId;
      });
    } else {
      // Add bookmark
      chrome.bookmarks.create({
        title: title || url,
        url: url
      }, (bookmark) => {
        bookmarkBtn.classList.add('saved');
        bookmarkBtn.dataset.bookmarkId = bookmark.id;
      });
    }
  }

  // Setup sort dropdown handler
  setupSortDropdown() {
    const sortDropdown = document.getElementById('sortMode');

    sortDropdown.addEventListener('change', (e) => {
      this.sortMode = e.target.value;

      // Check if expanded view is open and what type
      const expandedView = document.getElementById('expandedView');
      const wasOpen = expandedView.style.display === 'block';
      const viewType = this.expandedViewType;

      // Re-sort domains based on current view mode
      if (this.viewMode === 'hour') {
        this.sortedDomains = this.sortDomainsForHourView();
      } else {
        this.sortedDomains = this.getSortedDomains();
      }

      // Reset virtual state to force re-render
      this.virtualState = {
        startRow: -1,
        endRow: -1,
        startCol: -1,
        endCol: -1,
        viewportHeight: 0,
        viewportWidth: 0
      };

      // Rebuild the virtual grid
      this.setupVirtualGrid();

      // Refresh the expanded view if it was open (without closing it first)
      if (wasOpen) {
        if (viewType === 'full' || viewType === 'recent') {
          this.showFullHistory();
        } else if (viewType === 'closed') {
          this.showRecentlyClosed();
        } else if (viewType === 'day' && this.currentDate) {
          this.showDayExpandedView(this.currentDate);
        } else if (viewType === 'hour' && this.currentHour) {
          this.showHourExpandedView(this.currentHour);
        }
      }
    });
  }

  // Setup search input handler
  setupSearchInput() {
    const searchInput = document.getElementById('searchInput');

    searchInput.addEventListener('input', (e) => {
      this.searchFilter = e.target.value.trim();

      // Check if expanded view is open and what type
      const expandedView = document.getElementById('expandedView');
      const wasOpen = expandedView.style.display === 'block';
      const viewType = this.expandedViewType;

      this.refreshGrid();

      // Re-open the expanded view if it was open
      if (wasOpen) {
        if (viewType === 'recent' || viewType === 'full') {
          this.showFullHistory();
        } else if (viewType === 'bookmarks') {
          this.showBookmarks();
        } else if (viewType === 'closed') {
          this.showRecentlyClosed();
        }
        // Note: We don't re-open 'cell' or 'domain' views since filtering changes which domains are visible
      }
    });
  }

  // Refresh grid with current sort and filter
  refreshGrid() {
    // Re-sort/filter domains based on current view mode
    if (this.viewMode === 'hour') {
      this.sortedDomains = this.sortDomainsForHourView();
    } else {
      this.sortedDomains = this.getSortedDomains();
    }

    // Close any expanded view since row indices will change
    this.closeExpandedView();

    // Reset virtual state to force re-render
    this.virtualState = {
      startRow: -1,
      endRow: -1,
      startCol: -1,
      endCol: -1,
      viewportHeight: 0,
      viewportWidth: 0
    };

    // Rebuild the entire virtual grid
    this.setupVirtualGrid();
  }

  // Setup live updates for new visits
  setupLiveUpdates() {
    // Don't set up live updates for fake data
    if (this.useFakeData) {
      return;
    }

    // Listen for new history visits
    chrome.history.onVisited.addListener((historyItem) => {
      this.handleNewVisit(historyItem);
    });

    // Listen for storage changes (recently closed tabs)
    chrome.storage.onChanged.addListener((changes, area) => {
      if (area === 'local' && changes.closedTabs) {
        // If we're currently viewing recently closed, refresh it
        if (this.expandedViewType === 'closed') {
          this.showRecentlyClosed();
        }
      }
    });
  }

  // Handle a new visit from chrome.history.onVisited
  handleNewVisit(historyItem) {
    try {
      const url = new URL(historyItem.url);
      const domain = url.hostname.replace('www.', '');

      // Create date from timestamp
      const visitDateObj = new Date(historyItem.lastVisitTime);
      visitDateObj.setHours(0, 0, 0, 0);
      const visitDate = this.formatDate(visitDateObj);

      // Initialize domain if new
      if (!this.historyData[domain]) {
        this.historyData[domain] = {
          lastVisit: historyItem.lastVisitTime,
          days: {}
        };

        // Generate color for new domain
        if (!this.colors[domain]) {
          this.colors[domain] = this.generatePastelColor();
          this.saveColors();
        }

        // Update sorted domains (use appropriate method based on view mode)
        if (this.viewMode === 'hour') {
          this.sortedDomains = this.sortDomainsForHourView();
        } else {
          this.sortedDomains = this.getSortedDomains();
        }
      }

      // Initialize day if new
      if (!this.historyData[domain].days[visitDate]) {
        this.historyData[domain].days[visitDate] = {
          count: 0,
          urls: []
        };
      }

      // Update last visit if more recent
      if (historyItem.lastVisitTime > this.historyData[domain].lastVisit) {
        this.historyData[domain].lastVisit = historyItem.lastVisitTime;
      }

      // Find or add URL
      const urlData = this.historyData[domain].days[visitDate].urls.find(u => u.url === historyItem.url);

      if (urlData) {
        // URL exists, increment count
        urlData.visitCount++;
        urlData.lastVisit = historyItem.lastVisitTime;
      } else {
        // New URL
        this.historyData[domain].days[visitDate].urls.push({
          url: historyItem.url,
          title: historyItem.title,
          lastVisit: historyItem.lastVisitTime,
          visitCount: 1
        });
      }

      // Update day count
      this.historyData[domain].days[visitDate].count++;

      // Check if date is new and needs to be added to dates array
      if (!this.dates.includes(visitDate)) {
        // Check if date is today or in the future
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayStr = this.formatDate(today);

        const visitDateCheck = new Date(visitDate + 'T00:00:00');

        if (visitDateCheck >= new Date(this.dates[this.dates.length - 1] + 'T00:00:00')) {
          // Date is newer than our current range, regenerate dates
          this.generateDates();
          this.renderDateHeader();
        }
      }

      // Refresh the grid
      this.updateVirtualGrid();

      // Update expanded view based on what's currently open
      if (this.expandedViewType === 'domain' && this.currentDomain === domain) {
        this.showDomainView(domain);
      } else if (this.expandedViewType === 'cell' && this.selectedCell) {
        const cellDomain = this.selectedCell.dataset.domain;
        const cellDate = this.selectedCell.dataset.date;

        if (this.viewMode === 'hour') {
          // In hour view, cellDate is hourStr
          const visitHourStr = `${visitDate}T${String(new Date(historyItem.lastVisitTime).getHours()).padStart(2, '0')}`;
          if (cellDomain === domain && cellDate === visitHourStr) {
            // Update the domain-hour view
            const hourData = this.hourlyData[domain][visitHourStr];
            this.showDomainHourView(domain, visitHourStr, hourData.count);
          }
        } else {
          // In day view
          if (cellDomain === domain && cellDate === visitDate) {
            // Update the cell view
            const dayData = this.historyData[domain].days[visitDate];
            this.showExpandedView(domain, visitDate, dayData.count);
          }
        }
      } else if (this.expandedViewType === 'day' && this.currentDate) {
        // Refresh day view if the new visit is on the current date
        if (this.currentDate === visitDate) {
          this.showDayExpandedView(this.currentDate);
        }
      } else if (this.expandedViewType === 'hour' && this.currentHour) {
        // Refresh hour view if the new visit is in the current hour
        const visitHour = `${visitDate}T${String(new Date(historyItem.lastVisitTime).getHours()).padStart(2, '0')}`;
        if (this.currentHour === visitHour) {
          this.showHourExpandedView(this.currentHour);
        }
      } else if (this.expandedViewType === 'recent' || this.expandedViewType === 'full') {
        // Refresh full history view
        this.showFullHistory();
      }
      // Note: bookmarks and closed tabs don't need live updates from history

    } catch (e) {
      console.warn('Invalid URL in live update:', historyItem.url);
    }
  }

  // Setup bottom menu buttons
  setupBottomMenu() {
    document.getElementById('recentHistoryBtn').addEventListener('click', () => {
      this.showFullHistory();
    });

    document.getElementById('bookmarksBtn').addEventListener('click', () => {
      this.showBookmarks();
    });

    document.getElementById('recentlyClosedBtn').addEventListener('click', () => {
      this.showRecentlyClosed();
    });
  }

  // Scroll to show tomorrow on load
  scrollToToday() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayStr = this.formatDate(today);
    const todayIndex = this.dates.indexOf(todayStr);

    if (todayIndex !== -1) {
      const cellGridWrapper = document.getElementById('cellGridWrapper');
      const dateHeader = document.getElementById('dateHeader');

      // Calculate scroll position to show tomorrow (todayIndex + 1) at the right edge
      // This means today is visible, plus one day into the future
      const scrollLeft = (todayIndex + 2) * this.colWidth - cellGridWrapper.clientWidth;

      // Ensure we don't scroll past the end or before the beginning
      const maxScroll = Math.max(0, scrollLeft);

      cellGridWrapper.scrollLeft = maxScroll;
      dateHeader.scrollLeft = maxScroll;
    }
  }

  scrollToCurrentHour() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hour = String(now.getHours()).padStart(2, '0');
    const currentHourStr = `${year}-${month}-${day}T${hour}`;

    const currentHourIndex = this.hours.indexOf(currentHourStr);

    if (currentHourIndex !== -1) {
      const cellGridWrapper = document.getElementById('cellGridWrapper');
      const dateHeader = document.getElementById('dateHeader');

      // Calculate scroll position to show current hour with some context
      // Show current hour plus a few hours ahead
      const scrollLeft = (currentHourIndex + 4) * this.colWidth - cellGridWrapper.clientWidth;

      // Ensure we don't scroll past the end or before the beginning
      const maxScroll = Math.max(0, scrollLeft);

      cellGridWrapper.scrollLeft = maxScroll;
      dateHeader.scrollLeft = maxScroll;
    }
  }

  scrollToDateInHourView(dateStr) {
    // Scroll to noon (12pm) of the specified date to center the day
    const noonHourStr = `${dateStr}T12`;
    const noonHourIndex = this.hours.indexOf(noonHourStr);

    if (noonHourIndex !== -1) {
      const cellGridWrapper = document.getElementById('cellGridWrapper');
      const dateHeader = document.getElementById('dateHeader');

      // Center the noon hour in the viewport
      const scrollLeft = noonHourIndex * this.colWidth - (cellGridWrapper.clientWidth / 2);

      // Ensure we don't scroll past the end or before the beginning
      const maxScroll = Math.max(0, scrollLeft);

      cellGridWrapper.scrollLeft = maxScroll;
      dateHeader.scrollLeft = maxScroll;
    }
  }

  async switchToHourViewForDate(dateStr) {
    if (this.viewMode !== 'hour') {
      // Switch to hour view first
      await this.switchView('hour');
    }

    // Use requestAnimationFrame to ensure DOM is updated before scrolling
    requestAnimationFrame(() => {
      this.scrollToDateInHourView(dateStr);

      // Also show expanded view with all URLs from this day
      this.showDayExpandedView(dateStr);
    });
  }

  // Show expanded view with all URLs from a specific day (all domains)
  showDayExpandedView(dateStr) {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');

    // Set view type
    this.expandedViewType = 'day';
    this.currentDomain = null;
    this.currentDate = dateStr;

    // Remove delete domain button if it exists
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) {
      deleteBtn.remove();
    }

    // Format date nicely
    const dateObj = new Date(dateStr + 'T00:00:00');
    const formattedDate = dateObj.toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    });

    // Collect all URLs from all domains for this date
    const allUrls = [];
    let totalCount = 0;

    for (const domain in this.historyData) {
      const dayData = this.historyData[domain].days[dateStr];
      if (dayData && dayData.urls) {
        dayData.urls.forEach(urlData => {
          allUrls.push({
            ...urlData,
            domain: domain,
            date: dateStr
          });
        });
        totalCount += dayData.count;
      }
    }

    // Sort based on current sort mode
    if (this.sortMode === 'popular') {
      // Most Popular: Sort by visit count (descending)
      allUrls.sort((a, b) => b.visitCount - a.visitCount);
    } else if (this.sortMode === 'alphabetical') {
      // Alphabetical: Sort by domain, then by URL
      allUrls.sort((a, b) => {
        const domainCompare = a.domain.localeCompare(b.domain);
        if (domainCompare !== 0) return domainCompare;
        return a.url.localeCompare(b.url);
      });
    } else {
      // Most Recent (default): Sort by most recent visit
      allUrls.sort((a, b) => b.lastVisit - a.lastVisit);
    }

    // Set title
    expandedTitle.textContent = `${formattedDate} (${totalCount} visit${totalCount !== 1 ? 's' : ''})`;

    // Remove navigation controls if they exist (not needed for day view)
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) {
      navContainer.remove();
    }

    // Render calendar events for this date
    this.renderCalendarEventsForDate(dateStr);

    // Clear URL list
    urlList.innerHTML = '';

    if (allUrls.length === 0) {
      urlList.innerHTML = '<div class="no-urls">No visits on this day</div>';
    } else {
      // Only group by hour if sorting by recent time
      // For other sort modes, show flat list
      if (this.sortMode === 'recent') {
        // Group URLs by hour for better organization
        const urlsByHour = {};

      allUrls.forEach(urlData => {
        const visitDate = new Date(urlData.lastVisit);
        const hour = visitDate.getHours();
        const hourKey = `${String(hour).padStart(2, '0')}:00`;

        if (!urlsByHour[hourKey]) {
          urlsByHour[hourKey] = [];
        }
        urlsByHour[hourKey].push(urlData);
      });

      // Render URLs grouped by hour
      const hours = Object.keys(urlsByHour).sort().reverse(); // Most recent hour first

      hours.forEach(hourKey => {
        // Hour header
        const hourHeader = document.createElement('div');
        hourHeader.className = 'hour-group-header';
        const hourNum = parseInt(hourKey.split(':')[0]);
        const ampm = hourNum >= 12 ? 'PM' : 'AM';
        const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
        hourHeader.textContent = `${displayHour}:00 ${ampm} (${urlsByHour[hourKey].length} visit${urlsByHour[hourKey].length !== 1 ? 's' : ''})`;
        urlList.appendChild(hourHeader);

        // URLs for this hour - use the standard createUrlItem method
        urlsByHour[hourKey].forEach(urlData => {
          const urlItem = this.createUrlItem(urlData, urlData.domain, dateStr);
          urlList.appendChild(urlItem);
        });
      });
      } else {
        // For popular and alphabetical sort modes, show flat list without hour grouping
        allUrls.forEach(urlData => {
          const urlItem = this.createUrlItem(urlData, urlData.domain, dateStr);
          urlList.appendChild(urlItem);
        });
      }
    }

    // Show the expanded view
    this.showExpandedViewAnimated();
  }

  // Show expanded view for a specific domain and hour
  showDomainHourView(domain, hourStr, count) {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');

    // Set view type
    this.expandedViewType = 'cell';
    this.currentDomain = domain;
    this.currentDate = hourStr; // Store hourStr as currentDate for navigation

    // Hide calendar section (not used for single domain-hour view)
    const calendarSection = document.getElementById('calendarSection');
    if (calendarSection) {
      calendarSection.style.display = 'none';
    }

    // Parse hourStr (format: 'YYYY-MM-DDTHH')
    const [datePart, hourPart] = hourStr.split('T');
    const hourNum = parseInt(hourPart);

    // Format date and time nicely
    const dateObj = new Date(datePart + 'T00:00:00');
    const formattedDate = dateObj.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });

    // Format hour for display
    const ampm = hourNum >= 12 ? 'PM' : 'AM';
    const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
    const hourDisplay = `${displayHour}:00 ${ampm}`;

    // Set title
    expandedTitle.textContent = `${domain} - ${formattedDate} ${hourDisplay} (${count} visit${count !== 1 ? 's' : ''})`;

    // Remove delete domain button if it exists
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) {
      deleteBtn.remove();
    }

    // Remove navigation controls if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) {
      navContainer.remove();
    }

    // Get URLs for this domain and hour
    const hourData = this.hourlyData[domain]?.[hourStr];

    // Clear URL list
    urlList.innerHTML = '';

    if (!hourData || !hourData.urls || hourData.urls.length === 0) {
      urlList.innerHTML = '<div class="no-urls">No URLs found</div>';
      this.showExpandedViewAnimated();
      return;
    }

    // Sort URLs based on current sort mode
    let urls = [...hourData.urls];
    if (this.sortMode === 'popular') {
      urls.sort((a, b) => b.visitCount - a.visitCount);
    } else if (this.sortMode === 'alphabetical') {
      urls.sort((a, b) => a.url.localeCompare(b.url));
    } else {
      // Most Recent (default)
      urls.sort((a, b) => b.lastVisit - a.lastVisit);
    }

    // Add domain and date to each URL
    const urlsWithContext = urls.map(urlData => ({
      ...urlData,
      domain: domain,
      date: datePart
    }));

    // Render URLs
    urlsWithContext.forEach(urlData => {
      const urlItem = this.createUrlItem(urlData, domain, datePart);
      urlList.appendChild(urlItem);
    });

    // Show the expanded view
    this.showExpandedViewAnimated();
  }

  // Show expanded view for a specific hour with URLs and calendar events
  showHourExpandedView(hourStr) {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');

    // Set view type
    this.expandedViewType = 'hour';
    this.currentDomain = null;
    this.currentDate = null;
    this.currentHour = hourStr;

    // Remove delete domain button if it exists
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) {
      deleteBtn.remove();
    }

    // Parse hourStr (format: 'YYYY-MM-DDTHH')
    const [datePart, hourPart] = hourStr.split('T');
    const hourNum = parseInt(hourPart);

    // Format date and time nicely
    const dateObj = new Date(datePart + 'T00:00:00');
    const formattedDate = dateObj.toLocaleDateString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      year: 'numeric'
    });

    // Format hour for display
    const ampm = hourNum >= 12 ? 'PM' : 'AM';
    const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
    const hourDisplay = `${displayHour}:00 ${ampm}`;

    // Collect all URLs from all domains for this hour
    const allUrls = [];
    let totalCount = 0;

    for (const domain in this.hourlyData) {
      const hourData = this.hourlyData[domain]?.[hourStr];
      if (hourData && hourData.urls) {
        hourData.urls.forEach(urlData => {
          allUrls.push({
            ...urlData,
            domain: domain,
            date: datePart // Use date part for URL item creation
          });
        });
        totalCount += hourData.count;
      }
    }

    // Sort based on current sort mode
    if (this.sortMode === 'popular') {
      // Most Popular: Sort by visit count (descending)
      allUrls.sort((a, b) => b.visitCount - a.visitCount);
    } else if (this.sortMode === 'alphabetical') {
      // Alphabetical: Sort by domain, then by URL
      allUrls.sort((a, b) => {
        const domainCompare = a.domain.localeCompare(b.domain);
        if (domainCompare !== 0) return domainCompare;
        return a.url.localeCompare(b.url);
      });
    } else {
      // Most Recent (default): Sort by most recent visit
      allUrls.sort((a, b) => b.lastVisit - a.lastVisit);
    }

    // Set title
    expandedTitle.textContent = `${formattedDate} - ${hourDisplay} (${totalCount} visit${totalCount !== 1 ? 's' : ''})`;

    // Remove navigation controls if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) {
      navContainer.remove();
    }

    // Render calendar events for this specific hour
    this.renderCalendarEventsForHour(hourStr);

    // Clear URL list
    urlList.innerHTML = '';

    if (allUrls.length === 0) {
      urlList.innerHTML = '<div class="no-urls">No visits during this hour</div>';
    } else {
      // Render URLs based on sort mode
      allUrls.forEach(urlData => {
        const urlItem = this.createUrlItem(urlData, urlData.domain, datePart);
        urlList.appendChild(urlItem);
      });
    }

    // Show the expanded view
    this.showExpandedViewAnimated();
  }

  // Render calendar events for a specific hour in expanded view
  renderCalendarEventsForHour(hourStr) {
    const calendarSection = document.getElementById('calendarSection');
    const calendarEventsList = document.getElementById('calendarEventsList');

    // Only show if calendar integration is available
    if (typeof googleCalendar === 'undefined') {
      calendarSection.style.display = 'none';
      return;
    }

    // Parse hourStr (format: 'YYYY-MM-DDTHH')
    const [datePart, hourPart] = hourStr.split('T');
    const targetHour = parseInt(hourPart);

    // Get events for this date
    const events = googleCalendar.getEventsForDate(datePart);

    // Filter to only enabled calendars AND events that occur during this hour
    const enabledEvents = events.filter(event => {
      const calendar = googleCalendar.calendarData.calendars[event.calendarId];
      if (!calendar || !calendar.enabled) return false;

      // All-day events appear in every hour
      if (event.isAllDay) return true;

      // Timed events: check if this hour falls within the event time
      const startTime = new Date(event.start.dateTime);
      const endTime = new Date(event.end.dateTime);
      const startHour = startTime.getHours();
      const endHour = endTime.getHours();

      // Event occurs during this hour if:
      // - Event starts in this hour, OR
      // - Event ends in this hour, OR
      // - Event spans across this hour
      return (startHour <= targetHour && endHour >= targetHour) ||
             (startHour === targetHour) ||
             (endHour === targetHour && endTime.getMinutes() > 0);
    });

    if (enabledEvents.length === 0) {
      calendarSection.style.display = 'none';
      return;
    }

    calendarSection.style.display = 'block';
    calendarEventsList.innerHTML = '';
    calendarEventsList.classList.remove('collapsed');

    // Group events: all-day first, then by time
    const allDayEvents = enabledEvents.filter(e => e.isAllDay);
    const timedEvents = enabledEvents.filter(e => !e.isAllDay)
      .sort((a, b) => new Date(a.start.dateTime) - new Date(b.start.dateTime));

    // Render all-day events
    if (allDayEvents.length > 0) {
      const groupHeader = document.createElement('div');
      groupHeader.className = 'calendar-time-group';
      groupHeader.textContent = 'All Day';
      calendarEventsList.appendChild(groupHeader);

      allDayEvents.forEach(event => {
        const eventItem = this.createCalendarEventItem(event);
        calendarEventsList.appendChild(eventItem);
      });
    }

    // Render timed events
    if (timedEvents.length > 0) {
      const groupHeader = document.createElement('div');
      groupHeader.className = 'calendar-time-group';
      const hourLabel = targetHour === 0 ? 12 : (targetHour > 12 ? targetHour - 12 : targetHour);
      const ampm = targetHour >= 12 ? 'PM' : 'AM';
      groupHeader.textContent = `${hourLabel}:00 ${ampm}`;
      calendarEventsList.appendChild(groupHeader);

      timedEvents.forEach(event => {
        const eventItem = this.createCalendarEventItem(event);
        calendarEventsList.appendChild(eventItem);
      });
    }
  }

  // Setup zoom controls (Command+/Command-)
  setupZoomControls() {
    let currentZoom = 1.0;

    document.addEventListener('keydown', (e) => {
      // Check for Command/Ctrl + Plus/Minus
      if ((e.metaKey || e.ctrlKey) && (e.key === '+' || e.key === '=' || e.key === '-' || e.key === '0')) {
        e.preventDefault();

        if (e.key === '+' || e.key === '=') {
          // Zoom in
          currentZoom = Math.min(currentZoom + 0.1, 3.0);
        } else if (e.key === '-') {
          // Zoom out
          currentZoom = Math.max(currentZoom - 0.1, 0.5);
        } else if (e.key === '0') {
          // Reset zoom
          currentZoom = 1.0;
        }

        document.body.style.zoom = currentZoom;
      }
    });
  }

  // Setup resize handles for TLD column and expanded view
  setupResizeHandle() {
    // TLD Column resize
    const tldHandle = document.getElementById('tldResizeHandle');
    const tldColumn = document.getElementById('tldColumn');
    const headerSpacer = document.querySelector('.header-spacer');
    let isTldResizing = false;
    let startX = 0;
    let startWidth = 0;

    // Function to update handle position
    const updateHandlePosition = () => {
      const tldWidth = tldColumn.offsetWidth;
      tldHandle.style.left = `${tldWidth}px`;
    };

    // Load saved TLD width from storage
    chrome.storage.local.get(['tldColumnWidth'], (result) => {
      if (result.tldColumnWidth) {
        tldColumn.style.width = `${result.tldColumnWidth}px`;
        headerSpacer.style.width = `${result.tldColumnWidth}px`;
      }
      updateHandlePosition();

      // Scroll to today after TLD width is restored
      // Use requestAnimationFrame to ensure DOM has updated
      requestAnimationFrame(() => {
        this.scrollToToday();
      });
    });

    tldHandle.addEventListener('mousedown', (e) => {
      isTldResizing = true;
      startX = e.clientX;
      startWidth = tldColumn.offsetWidth;
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });

    // Expanded view resize
    const expandedHandle = document.getElementById('expandedResizeHandle');
    const expandedView = document.getElementById('expandedView');
    let isExpandedResizing = false;
    let startY = 0;
    let startHeight = 0;

    // Load saved expanded view height from storage
    chrome.storage.local.get(['expandedViewHeight'], (result) => {
      if (result.expandedViewHeight) {
        expandedView.style.height = `${result.expandedViewHeight}px`;
      } else {
        // Default height if none saved - use 60% of viewport
        expandedView.style.height = `${window.innerHeight * 0.6}px`;
      }
      // Update padding if expanded view is visible
      if (expandedView.style.display === 'block') {
        this.updateExpandedViewPadding();
      }
    });

    expandedHandle.addEventListener('mousedown', (e) => {
      isExpandedResizing = true;
      startY = e.clientY;
      startHeight = expandedView.offsetHeight;
      document.body.style.cursor = 'row-resize';
      document.body.style.userSelect = 'none';
    });

    // Combined mousemove handler
    document.addEventListener('mousemove', (e) => {
      if (isTldResizing) {
        const delta = e.clientX - startX;
        const newWidth = Math.max(100, Math.min(400, startWidth + delta)); // Min 100px, max 400px

        tldColumn.style.width = `${newWidth}px`;
        headerSpacer.style.width = `${newWidth}px`;
        updateHandlePosition();
      }

      if (isExpandedResizing) {
        const delta = startY - e.clientY; // Inverted because dragging up increases height
        const newHeight = Math.max(150, Math.min(window.innerHeight * 0.95, startHeight + delta)); // Min 150px, max 95vh

        expandedView.style.height = `${newHeight}px`;
        this.updateExpandedViewPadding();
      }
    });

    // Combined mouseup handler
    document.addEventListener('mouseup', () => {
      if (isTldResizing) {
        isTldResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // Save the new width to storage
        const newWidth = tldColumn.offsetWidth;
        chrome.storage.local.set({ tldColumnWidth: newWidth });
      }

      if (isExpandedResizing) {
        isExpandedResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // Save the new height to storage
        const newHeight = expandedView.offsetHeight;
        chrome.storage.local.set({ expandedViewHeight: newHeight });
      }
    });
  }

  // Show recent history (last 100 visits)
  showRecentHistory() {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');

    this.expandedViewType = 'recent';
    this.currentDomain = null;

    expandedTitle.textContent = 'Recent History';

    // Remove navigation and delete button if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) navContainer.remove();
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) deleteBtn.remove();

    // Get recent history from Chrome
    chrome.history.search({
      text: '',
      maxResults: 1000,
      startTime: 0
    }, (results) => {
      const recentUrls = results.map(item => ({
        url: item.url,
        title: item.title || item.url,
        visitCount: item.visitCount,
        lastVisit: item.lastVisitTime,
        domain: new URL(item.url).hostname.replace(/^www\./, ''),
        date: new Date(item.lastVisitTime).toISOString().split('T')[0]
      }));

      // Sort by most recent
      recentUrls.sort((a, b) => b.lastVisit - a.lastVisit);

      this.expandedUrls = recentUrls;
      expandedTitle.textContent = `Recent History (${recentUrls.length} total)`;
      this.renderUrlList();

      this.showExpandedViewAnimated();
    });
  }

  // Show bookmarks organized by folders
  async showBookmarks() {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');
    const urlList = document.getElementById('urlList');

    // Hide calendar section (not used in bookmarks view)
    const calendarSection = document.getElementById('calendarSection');
    if (calendarSection) {
      calendarSection.style.display = 'none';
    }

    this.expandedViewType = 'bookmarks';
    this.currentDomain = null;

    expandedTitle.textContent = 'Bookmarks';

    // Remove navigation and delete button if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) navContainer.remove();
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) deleteBtn.remove();

    // Get all bookmarks
    chrome.bookmarks.getTree((bookmarkTree) => {
      const bookmarks = [];

      // Recursively collect all bookmarks with folder info
      const collectBookmarks = (nodes, folderPath = [], parentId = null) => {
        nodes.forEach(node => {
          if (node.url) {
            // It's a bookmark
            try {
              bookmarks.push({
                url: node.url,
                title: node.title || node.url,
                folder: folderPath.join(' > ') || 'Root',
                folderId: node.parentId || parentId, // Store the parent folder ID
                dateAdded: node.dateAdded,
                domain: new URL(node.url).hostname.replace(/^www\./, ''),
                visitCount: 1,
                lastVisit: node.dateAdded
              });
            } catch (e) {
              console.warn('Invalid bookmark URL:', node.url);
            }
          } else if (node.children) {
            // It's a folder
            const newPath = node.title ? [...folderPath, node.title] : folderPath;
            collectBookmarks(node.children, newPath, node.id);
          }
        });
      };

      collectBookmarks(bookmarkTree);

      // Sort by date added (most recent first)
      bookmarks.sort((a, b) => b.dateAdded - a.dateAdded);

      // Store bookmarks and render with filtering
      this.expandedUrls = bookmarks;
      expandedTitle.textContent = `Bookmarks (${bookmarks.length} total)`;
      this.renderUrlList();

      this.showExpandedViewAnimated();
    });
  }


  // Show recently closed tabs with restore functionality
  showRecentlyClosed() {
    const expandedView = document.getElementById('expandedView');
    const expandedTitle = document.getElementById('expandedTitle');

    // Hide calendar section (not used in recently closed view)
    const calendarSection = document.getElementById('calendarSection');
    if (calendarSection) {
      calendarSection.style.display = 'none';
    }

    this.expandedViewType = 'closed';
    this.currentDomain = null;

    expandedTitle.textContent = 'Recently Closed';

    // Remove navigation and delete button if they exist
    const navContainer = document.getElementById('expandedNav');
    if (navContainer) navContainer.remove();
    const deleteBtn = document.getElementById('deleteDomain');
    if (deleteBtn) deleteBtn.remove();

    // Get closed tabs from storage
    chrome.storage.local.get(['closedTabs'], (result) => {
      const closedTabs = result.closedTabs || [];

      // Convert to URL format and add domain
      const closedUrls = closedTabs.map(tabData => {
        try {
          return {
            url: tabData.url,
            title: tabData.title,
            favIconUrl: tabData.favIconUrl,
            closedAt: tabData.closedAt,
            domain: new URL(tabData.url).hostname.replace(/^www\./, ''),
            visitCount: 1,
            lastVisit: tabData.closedAt
          };
        } catch (e) {
          return {
            url: tabData.url,
            title: tabData.title,
            favIconUrl: tabData.favIconUrl,
            closedAt: tabData.closedAt,
            domain: tabData.url,
            visitCount: 1,
            lastVisit: tabData.closedAt
          };
        }
      });

      // Sort based on current sort mode
      if (this.sortMode === 'popular') {
        // Most Popular: For closed tabs, just use most recent since we don't have visit counts
        closedUrls.sort((a, b) => b.closedAt - a.closedAt);
      } else if (this.sortMode === 'alphabetical') {
        // Alphabetical: Sort by domain, then by URL
        closedUrls.sort((a, b) => {
          const domainCompare = a.domain.localeCompare(b.domain);
          if (domainCompare !== 0) return domainCompare;
          return a.url.localeCompare(b.url);
        });
      } else {
        // Most Recent (default): Sort by most recently closed
        closedUrls.sort((a, b) => b.closedAt - a.closedAt);
      }

      this.expandedUrls = closedUrls;
      expandedTitle.textContent = `Recently Closed (${closedUrls.length} total)`;
      this.renderUrlList();

      this.showExpandedViewAnimated();
    });
  }

  // Create a closed tab item
  createClosedTabItem(tabData, index) {
    const item = document.createElement('div');
    item.className = 'url-item';

    // Left side: restore button
    const leftDiv = document.createElement('div');
    leftDiv.className = 'url-item-left';

    const restoreBtn = document.createElement('button');
    restoreBtn.className = 'icon-btn restore';
    restoreBtn.textContent = 'âŸ²';
    restoreBtn.title = 'Reopen this tab';
    restoreBtn.addEventListener('click', async () => {
      // Open the URL in a new tab
      chrome.tabs.create({ url: tabData.url });

      // Remove this item from storage
      const result = await chrome.storage.local.get(['closedTabs']);
      const closedTabs = result.closedTabs || [];
      closedTabs.splice(index, 1);
      await chrome.storage.local.set({ closedTabs });

      // Refresh the list
      this.showRecentlyClosed();
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'icon-btn delete';
    deleteBtn.textContent = 'ðŸ—‘ï¸';
    deleteBtn.title = 'Remove from list';
    deleteBtn.addEventListener('click', async () => {
      // Remove this item from storage
      const result = await chrome.storage.local.get(['closedTabs']);
      const closedTabs = result.closedTabs || [];
      closedTabs.splice(index, 1);
      await chrome.storage.local.set({ closedTabs });

      // Refresh the list
      this.showRecentlyClosed();
    });

    leftDiv.appendChild(restoreBtn);
    leftDiv.appendChild(deleteBtn);

    // Right side: Favicon + Title/URL info
    const rightDiv = document.createElement('div');
    rightDiv.className = 'url-item-right';

    // Add favicon
    const favicon = document.createElement('img');
    favicon.className = 'url-favicon';
    favicon.src = tabData.favIconUrl || `https://www.google.com/s2/favicons?domain=${tabData.url}&sz=16`;
    favicon.alt = '';
    favicon.width = 16;
    favicon.height = 16;

    // Create clickable link
    const urlLink = document.createElement('a');
    urlLink.href = tabData.url;
    urlLink.target = '_blank';

    // Truncate URLs longer than 400 characters
    if (tabData.url.length > 400) {
      urlLink.textContent = tabData.title || tabData.url.substring(0, 400) + '...';
      urlLink.title = tabData.url;
    } else {
      urlLink.textContent = tabData.title || tabData.url;
    }

    rightDiv.appendChild(favicon);
    rightDiv.appendChild(urlLink);

    item.appendChild(leftDiv);
    item.appendChild(rightDiv);

    // Add hover preview to the URL link
    // Create urlData object compatible with attachUrlPreview
    const urlData = {
      url: tabData.url,
      title: tabData.title,
      visitCount: 1, // We don't track visit count for closed tabs
      lastVisit: tabData.closedAt // Use closed time as "last visit"
    };
    this.attachUrlPreview(urlLink, urlData);

    return item;
  }

  // ===== CALENDAR INTEGRATION METHODS =====

  /**
   * Initialize calendar service and load data
   */
  async initializeCalendar() {
    try {
      // Load calendar data from storage
      await googleCalendar.loadCalendarData();

      // Check if authenticated
      const authStatus = await googleCalendar.checkAuthStatus();

      if (authStatus.authenticated) {
        // Fetch calendar list if we don't have it
        if (Object.keys(googleCalendar.calendarData.calendars).length === 0) {
          await googleCalendar.fetchCalendarList();
        }

        // Fetch events for current date range
        const startDate = this.dates[0];
        const endDate = this.dates[this.dates.length - 1];
        await googleCalendar.fetchEventsForDateRange(startDate, endDate);
      }
    } catch (error) {
      console.error('Failed to initialize calendar:', error);
    }
  }

  /**
   * Setup calendar UI event handlers
   */
  setupCalendarUI() {
    const settingsBtn = document.getElementById('calendarSettingsBtn');
    const modal = document.getElementById('calendarSettingsModal');
    const closeModalBtn = document.getElementById('closeCalendarModal');
    const modalOverlay = document.getElementById('modalOverlay');
    const connectBtn = document.getElementById('connectCalendarBtn');
    const disconnectBtn = document.getElementById('disconnectCalendarBtn');
    const refreshBtn = document.getElementById('refreshCalendarsBtn');
    const sectionToggle = document.getElementById('calendarSectionToggle');
    const sectionHeader = document.getElementById('calendarSectionHeader');

    // Open settings modal
    settingsBtn.addEventListener('click', async () => {
      await this.openCalendarSettings();
    });

    // Close modal
    const closeModal = () => {
      modal.style.display = 'none';
    };

    closeModalBtn.addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', closeModal);

    // Connect calendar
    connectBtn.addEventListener('click', async () => {
      connectBtn.disabled = true;
      connectBtn.textContent = 'Connecting...';

      try {
        const result = await googleCalendar.authenticateUser();

        if (result.success) {
          // Update UI
          await this.updateCalendarAuthUI();

          // Fetch calendar list
          await googleCalendar.fetchCalendarList();
          this.renderCalendarList();

          // Fetch events for current date range
          const startDate = this.dates[0];
          const endDate = this.dates[this.dates.length - 1];
          await googleCalendar.fetchEventsForDateRange(startDate, endDate);

          // Refresh grid to show event indicators
          this.updateVirtualGrid();
        } else {
          alert('Failed to connect to Google Calendar: ' + (result.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Authentication error:', error);
        alert('Failed to connect to Google Calendar');
      } finally {
        connectBtn.disabled = false;
        connectBtn.textContent = 'Connect Google Calendar';
      }
    });

    // Disconnect calendar
    disconnectBtn.addEventListener('click', async () => {
      if (confirm('Disconnect from Google Calendar? Your calendar events will no longer be displayed.')) {
        await googleCalendar.revokeToken();
        await this.updateCalendarAuthUI();

        // Refresh grid to remove event indicators
        this.updateVirtualGrid();
      }
    });

    // Refresh calendar list
    refreshBtn.addEventListener('click', async () => {
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'ðŸ”„ Refreshing...';

      try {
        await googleCalendar.fetchCalendarList();
        this.renderCalendarList();

        // Re-fetch events
        const startDate = this.dates[0];
        const endDate = this.dates[this.dates.length - 1];
        await googleCalendar.fetchEventsForDateRange(startDate, endDate);

        // Refresh calendar events in header
        this.renderDateHeader();

        // Refresh grid (force update to re-render calendar dots)
        this.updateVirtualGrid(true);
      } catch (error) {
        console.error('Failed to refresh calendars:', error);
        alert('Failed to refresh calendar list');
      } finally {
        refreshBtn.disabled = false;
        refreshBtn.textContent = 'ðŸ”„ Refresh Calendar List';
      }
    });

    // Toggle calendar section in expanded view
    if (sectionHeader) {
      sectionHeader.addEventListener('click', () => {
        const eventsList = document.getElementById('calendarEventsList');
        const isCollapsed = eventsList.classList.contains('collapsed');

        if (isCollapsed) {
          eventsList.classList.remove('collapsed');
          sectionToggle.classList.remove('collapsed');
          sectionToggle.textContent = 'â–¼';
        } else {
          eventsList.classList.add('collapsed');
          sectionToggle.classList.add('collapsed');
          sectionToggle.textContent = 'â–¶';
        }
      });
    }
  }

  /**
   * Open calendar settings modal and update UI
   */
  async openCalendarSettings() {
    const modal = document.getElementById('calendarSettingsModal');
    modal.style.display = 'flex';

    await this.updateCalendarAuthUI();
  }

  /**
   * Update calendar authentication UI state
   */
  async updateCalendarAuthUI() {
    const authStatus = await googleCalendar.checkAuthStatus();
    const authStatusEl = document.getElementById('authStatus');
    const authStatusText = authStatusEl.querySelector('.auth-status-text');
    const connectBtn = document.getElementById('connectCalendarBtn');
    const disconnectBtn = document.getElementById('disconnectCalendarBtn');
    const calendarListSection = document.getElementById('calendarListSection');

    if (authStatus.authenticated) {
      authStatusEl.classList.add('authenticated');
      authStatusText.textContent = `âœ“ Connected as ${authStatus.email}`;
      connectBtn.style.display = 'none';
      disconnectBtn.style.display = 'block';
      calendarListSection.style.display = 'block';

      this.renderCalendarList();
    } else {
      authStatusEl.classList.remove('authenticated');
      authStatusText.textContent = 'Not connected';
      connectBtn.style.display = 'block';
      disconnectBtn.style.display = 'none';
      calendarListSection.style.display = 'none';
    }
  }

  /**
   * Render calendar list with checkboxes
   */
  renderCalendarList() {
    const calendarList = document.getElementById('calendarList');
    calendarList.innerHTML = '';

    const calendars = Object.values(googleCalendar.calendarData.calendars);

    if (calendars.length === 0) {
      calendarList.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No calendars found</p>';
      return;
    }

    calendars.forEach(calendar => {
      const item = document.createElement('div');
      item.className = 'calendar-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = calendar.enabled;
      checkbox.addEventListener('change', async (e) => {
        await googleCalendar.toggleCalendar(calendar.id, e.target.checked);

        // Re-fetch events
        const startDate = this.dates[0];
        const endDate = this.dates[this.dates.length - 1];
        await googleCalendar.fetchEventsForDateRange(startDate, endDate);

        // Refresh calendar events in header
        this.renderDateHeader();

        // Refresh grid (force update to re-render calendar dots)
        this.updateVirtualGrid(true);

        // Refresh expanded view if open
        if (this.expandedViewType === 'cell' && this.selectedCell) {
          // Cell view doesn't show calendar events in domain-hour view
          // Only refresh if in day view mode
          if (this.viewMode === 'day') {
            const date = this.selectedCell.dataset.date;
            this.renderCalendarEventsForDate(date);
          }
        } else if (this.expandedViewType === 'day' && this.currentDate) {
          this.renderCalendarEventsForDate(this.currentDate);
        } else if (this.expandedViewType === 'hour' && this.currentHour) {
          this.renderCalendarEventsForHour(this.currentHour);
        }
      });

      const colorDiv = document.createElement('div');
      colorDiv.className = 'calendar-color';
      colorDiv.style.backgroundColor = calendar.backgroundColor;

      const nameSpan = document.createElement('span');
      nameSpan.className = 'calendar-name';
      nameSpan.textContent = calendar.name;

      item.appendChild(checkbox);
      item.appendChild(colorDiv);
      item.appendChild(nameSpan);

      calendarList.appendChild(item);
    });
  }

  /**
   * Render calendar events for a specific date in expanded view
   */
  renderCalendarEventsForDate(dateStr) {
    const calendarSection = document.getElementById('calendarSection');
    const calendarEventsList = document.getElementById('calendarEventsList');

    // Get events for this date
    const events = googleCalendar.getEventsForDate(dateStr);
    const enabledEvents = events.filter(evt =>
      googleCalendar.calendarData.calendars[evt.calendarId]?.enabled
    );

    if (enabledEvents.length === 0) {
      calendarSection.style.display = 'none';
      return;
    }

    calendarSection.style.display = 'block';
    calendarEventsList.innerHTML = '';
    calendarEventsList.classList.remove('collapsed');

    // Group events: all-day first, then by time
    const allDayEvents = enabledEvents.filter(e => e.isAllDay);
    const timedEvents = enabledEvents.filter(e => !e.isAllDay)
      .sort((a, b) => new Date(a.start.dateTime) - new Date(b.start.dateTime));

    // Render all-day events
    if (allDayEvents.length > 0) {
      const groupHeader = document.createElement('div');
      groupHeader.className = 'calendar-time-group';
      groupHeader.textContent = 'All Day';
      calendarEventsList.appendChild(groupHeader);

      allDayEvents.forEach(evt => {
        calendarEventsList.appendChild(this.createCalendarEventItem(evt));
      });
    }

    // Render timed events
    if (timedEvents.length > 0) {
      if (allDayEvents.length > 0) {
        const groupHeader = document.createElement('div');
        groupHeader.className = 'calendar-time-group';
        groupHeader.textContent = 'Scheduled';
        calendarEventsList.appendChild(groupHeader);
      }

      timedEvents.forEach(evt => {
        calendarEventsList.appendChild(this.createCalendarEventItem(evt));
      });
    }
  }

  /**
   * Create a calendar event item element
   */
  createCalendarEventItem(event) {
    const item = document.createElement('div');
    item.className = 'calendar-event-item';
    item.style.borderLeftColor = event.backgroundColor;

    // Time
    const timeDiv = document.createElement('div');
    timeDiv.className = 'calendar-event-time';
    if (event.isAllDay) {
      timeDiv.className += ' all-day';
      timeDiv.textContent = 'All day';
    } else {
      const start = new Date(event.start.dateTime);
      const end = new Date(event.end.dateTime);
      timeDiv.textContent = this.formatTimeRange(start, end);
    }

    // Details
    const detailsDiv = document.createElement('div');
    detailsDiv.className = 'calendar-event-details';

    const summary = document.createElement('div');
    summary.className = 'calendar-event-summary';
    summary.textContent = event.summary;

    const meta = document.createElement('div');
    meta.className = 'calendar-event-meta';

    // Calendar name with color
    const calendarInfo = document.createElement('div');
    calendarInfo.className = 'calendar-event-calendar';
    const colorIndicator = document.createElement('div');
    colorIndicator.className = 'calendar-color-indicator';
    colorIndicator.style.backgroundColor = event.backgroundColor;
    calendarInfo.appendChild(colorIndicator);
    calendarInfo.appendChild(document.createTextNode(event.calendarName));
    meta.appendChild(calendarInfo);

    // Location
    if (event.location) {
      const location = document.createElement('div');
      location.className = 'calendar-event-location';
      location.textContent = `ðŸ“ ${event.location}`;
      meta.appendChild(location);
    }

    detailsDiv.appendChild(summary);
    detailsDiv.appendChild(meta);

    // Actions
    const actions = document.createElement('div');
    actions.className = 'calendar-event-actions';

    const viewLink = document.createElement('a');
    viewLink.className = 'calendar-event-link';
    viewLink.textContent = 'View';
    viewLink.href = event.htmlLink || `https://calendar.google.com/calendar/event?eid=${event.id}`;
    viewLink.target = '_blank';
    viewLink.rel = 'noopener noreferrer';
    actions.appendChild(viewLink);

    item.appendChild(timeDiv);
    item.appendChild(detailsDiv);
    item.appendChild(actions);

    return item;
  }

  /**
   * Format time range for display
   */
  formatTimeRange(start, end) {
    const startTime = start.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    const endTime = end.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    return `${startTime} - ${endTime}`;
  }

  /**
   * Refresh calendar UI after background sync updates
   */
  async refreshCalendarUI() {
    // Reload calendar data from storage
    await googleCalendar.loadCalendarData();

    // Refresh date header to show new events
    this.renderDateHeader();

    // Refresh expanded view if it's showing calendar events
    if (this.expandedViewType === 'cell' && this.selectedCell) {
      // Cell view only shows calendar events in day view mode
      if (this.viewMode === 'day') {
        const date = this.selectedCell.dataset.date;
        this.renderCalendarEventsForDate(date);
      }
    } else if (this.expandedViewType === 'day' && this.currentDate) {
      this.renderCalendarEventsForDate(this.currentDate);
    } else if (this.expandedViewType === 'hour' && this.currentHour) {
      this.renderCalendarEventsForHour(this.currentHour);
    }
  }

  /**
   * Render calendar events for a specific date column in the header
   */
  // Render calendar events for a specific hour (hour view)
  renderCalendarEventColumnForHour(eventColumn, hourStr) {
    // Only show events if calendar integration is available
    if (typeof googleCalendar === 'undefined') {
      return false;
    }

    // Parse hourStr like '2025-12-01T14'
    const [datePart, hourPart] = hourStr.split('T');
    const targetHour = parseInt(hourPart);

    const events = googleCalendar.getEventsForDate(datePart);

    // Filter to only enabled calendars AND events that occur during this hour
    const enabledEvents = events.filter(event => {
      const calendar = googleCalendar.calendarData.calendars[event.calendarId];
      if (!calendar || !calendar.enabled) return false;

      // All-day events appear in every hour
      if (event.isAllDay) return true;

      // Timed events: check if this hour falls within the event time
      const startTime = new Date(event.start.dateTime);
      const endTime = new Date(event.end.dateTime);
      const startHour = startTime.getHours();
      const endHour = endTime.getHours();

      // Event occurs during this hour if:
      // - Event starts in this hour, OR
      // - Event ends in this hour, OR
      // - Event spans across this hour
      return targetHour >= startHour && targetHour <= endHour;
    });

    if (enabledEvents.length === 0) {
      return false;
    }

    // Use the same rendering logic as renderCalendarEventColumn
    return this.renderCalendarEventDots(eventColumn, enabledEvents, datePart);
  }

  // Common method to render event dots
  renderCalendarEventDots(eventColumn, enabledEvents, dateStr) {
    // Sort events chronologically (all-day first, then by start time)
    const sortedEvents = [...enabledEvents].sort((a, b) => {
      if (a.isAllDay && !b.isAllDay) return -1;
      if (!a.isAllDay && b.isAllDay) return 1;

      const aTime = a.start.dateTime || a.start.date;
      const bTime = b.start.dateTime || b.start.date;
      return new Date(aTime).getTime() - new Date(bTime).getTime();
    });

    // Function to position tooltip
    const positionTooltip = () => {
      const tooltip = document.getElementById('tooltip');
      if (!tooltip.classList.contains('visible')) return;

      const rect = eventColumn.getBoundingClientRect();
      tooltip.style.left = `${rect.left - tooltip.offsetWidth - 10}px`;
      tooltip.style.top = `${rect.top}px`;
    };

    // Add hover handler to show all events for this day
    eventColumn.addEventListener('mouseenter', (e) => {
      const tooltip = document.getElementById('tooltip');

      // Build tooltip content with all events using HTML
      let tooltipHTML = '';
      sortedEvents.forEach((event, idx) => {
        const color = event.backgroundColor || '#039BE5';
        const dotStyle = `width: 8px; height: 8px; border-radius: 50%; background-color: ${color}; flex-shrink: 0; margin-top: 4px;`;
        const eventStyle = `display: flex; gap: 8px; margin-bottom: 8px;`;

        if (event.isAllDay) {
          tooltipHTML += `<div style="${eventStyle}"><div style="${dotStyle}"></div><div>All day<br>${event.summary}</div></div>`;
        } else {
          const start = new Date(event.start.dateTime);
          const end = new Date(event.end.dateTime);
          const startTime = start.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
          const endTime = end.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
          tooltipHTML += `<div style="${eventStyle}"><div style="${dotStyle}"></div><div>${startTime}-${endTime}<br>${event.summary}</div></div>`;
        }
      });

      tooltip.innerHTML = tooltipHTML;
      tooltip.style.whiteSpace = 'normal';
      tooltip.style.maxWidth = '200px';
      tooltip.classList.add('visible');

      // Wait for DOM to update with new content size, then position
      requestAnimationFrame(() => {
        positionTooltip();
      });

      // Store reference to this column for scroll repositioning
      eventColumn.dataset.tooltipActive = 'true';
    });

    eventColumn.addEventListener('mouseleave', () => {
      const tooltip = document.getElementById('tooltip');
      tooltip.classList.remove('visible');
      tooltip.style.whiteSpace = 'normal';
      delete eventColumn.dataset.tooltipActive;
    });

    // Add scroll handler to reposition tooltip
    const dateHeaderScroll = document.getElementById('dateHeader');
    const scrollHandler = () => {
      if (eventColumn.dataset.tooltipActive === 'true') {
        positionTooltip();
      }
    };
    dateHeaderScroll.addEventListener('scroll', scrollHandler);
    document.getElementById('cellGridWrapper').addEventListener('scroll', scrollHandler);

    // Calculate total rows needed (max 10 rows = 20 events)
    const totalRows = Math.min(Math.ceil(enabledEvents.length / 2), 10);

    // Set the grid to only have the rows we need
    eventColumn.style.gridTemplateRows = `repeat(${totalRows}, 7px)`;

    // Set height to match the grid content (rows * 7px + gap between rows + padding)
    const height = totalRows * 7 + (totalRows - 1) * 1 + 2; // 7px per row + 1px gap + 2px padding
    eventColumn.style.height = `${height}px`;
    eventColumn.style.alignSelf = 'end';

    // Render all events as dots in a 2-column grid, filling bottom-up, left-to-right
    for (let i = 0; i < enabledEvents.length; i++) {
      const event = enabledEvents[i];
      const dot = document.createElement('div');
      dot.className = 'calendar-event-dot-header';
      dot.style.backgroundColor = event.backgroundColor || '#039BE5';

      // Calculate grid position: fill bottom-up, left column first
      // Event 0 -> bottom row, col 1
      // Event 1 -> bottom row, col 2
      // Event 2 -> second from bottom, col 1
      // Event 3 -> second from bottom, col 2
      const rowFromBottom = Math.floor(i / 2);
      const actualRow = totalRows - rowFromBottom;  // Count from totalRows (bottom)
      const col = (i % 2) + 1;

      dot.style.gridRow = `${actualRow}`;
      dot.style.gridColumn = `${col}`;

      // Add click handler to show event details
      dot.addEventListener('click', (e) => {
        e.stopPropagation();
        // Find the corresponding day cell and trigger its click
        const colIndex = Array.from(eventColumn.parentElement.children).indexOf(eventColumn);
        const dayCell = document.querySelector(`.day-cell[data-col-index="${colIndex}"]`);
        if (dayCell) {
          dayCell.click();
        }
      });

      eventColumn.appendChild(dot);
    }

    return true; // Events were rendered
  }

  renderCalendarEventColumn(eventColumn, dateStr) {
    // Only show events if calendar integration is available
    if (typeof googleCalendar === 'undefined') {
      return false;
    }

    const events = googleCalendar.getEventsForDate(dateStr);

    // Filter to only enabled calendars
    const enabledEvents = events.filter(event => {
      const calendar = googleCalendar.calendarData.calendars[event.calendarId];
      return calendar && calendar.enabled;
    });

    if (enabledEvents.length === 0) {
      return false;
    }

    return this.renderCalendarEventDots(eventColumn, enabledEvents, dateStr);
  }

  // ===== VIEW TOGGLE (Hour/Day) =====

  setupViewToggle() {
    const viewToggleBtns = document.querySelectorAll('.view-toggle-btn');

    viewToggleBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const view = btn.dataset.view;
        this.switchView(view);
      });
    });
  }

  async switchView(view) {
    console.log('switchView called, changing from', this.viewMode, 'to', view);

    if (this.viewMode === view) return; // Already in this view

    this.viewMode = view;
    console.log('viewMode now set to:', this.viewMode);

    // Save view mode to localStorage
    localStorage.setItem('bulletHistoryViewMode', view);

    // Update button states
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      if (btn.dataset.view === view) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    if (view === 'hour') {
      // Switch to hour view - generate hours for entire range
      console.log('Switching to hour view');
      this.generateHours();
      await this.organizeHistoryByHour();

      // Update sorted domains list from hourly data
      this.sortedDomains = this.sortDomainsForHourView();
      console.log('Hour view sortedDomains:', this.sortedDomains.length, 'domains');
    } else {
      // Switch back to day view - restore domains from historyData
      this.sortedDomains = this.getSortedDomains();
      console.log('Day view sortedDomains:', this.sortedDomains.length, 'domains');
    }

    // Re-render everything
    this.renderDateHeader();
    this.setupVirtualGrid();

    // Use requestAnimationFrame to ensure DOM is updated before scrolling
    requestAnimationFrame(() => {
      const cellGridWrapper = document.getElementById('cellGridWrapper');
      cellGridWrapper.scrollTop = 0;

      // Scroll to appropriate position based on view mode
      if (view === 'hour') {
        this.scrollToCurrentHour();
      } else {
        this.scrollToToday();
      }

      // Force update after scroll
      this.updateVirtualGrid(true);
    });
  }

  async organizeHistoryByHour() {
    console.log('Organizing history by hour...');
    console.log('historyData domains:', Object.keys(this.historyData).length);

    const hourlyData = {};

    // Go through each domain in historyData
    for (const domain in this.historyData) {
      const domainData = this.historyData[domain];

      // Go through each day
      for (const dateStr in domainData.days) {
        const dayData = domainData.days[dateStr];
        console.log(`Processing ${domain} - ${dateStr}: ${dayData.urls?.length || 0} urls`);

        // For each URL visited on this day
        if (dayData.urls && dayData.urls.length > 0) {
          dayData.urls.forEach(urlData => {
            const visitDate = new Date(urlData.lastVisit);
            const year = visitDate.getFullYear();
            const month = String(visitDate.getMonth() + 1).padStart(2, '0');
            const day = String(visitDate.getDate()).padStart(2, '0');
            const hour = String(visitDate.getHours()).padStart(2, '0');
            const hourStr = `${year}-${month}-${day}T${hour}`;

            // Initialize domain if needed
            if (!hourlyData[domain]) {
              hourlyData[domain] = {};
            }

            // Initialize hour if needed
            if (!hourlyData[domain][hourStr]) {
              hourlyData[domain][hourStr] = { count: 0, urls: [] };
            }

            // Add visit to this hour
            hourlyData[domain][hourStr].count++;
            hourlyData[domain][hourStr].urls.push(urlData);
          });
        }
      }
    }

    console.log('Hourly data organized:', Object.keys(hourlyData).length, 'domains');
    console.log('Total hours with data:',
      Object.values(hourlyData).reduce((sum, domainData) =>
        sum + Object.keys(domainData).length, 0));

    // Show a sample
    const sampleDomain = Object.keys(hourlyData)[0];
    if (sampleDomain) {
      console.log('Sample domain:', sampleDomain);
      console.log('Sample hours:', Object.keys(hourlyData[sampleDomain]).slice(0, 5));
      console.log('Sample hour data:', hourlyData[sampleDomain][Object.keys(hourlyData[sampleDomain])[0]]);
    }

    this.hourlyData = hourlyData;
  }

  formatHourLabel(hour) {
    // Format as 12-hour time: 12a, 1a, 2a, ..., 11a, 12p, 1p, ..., 11p
    const isPM = hour >= 12;
    const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
    return `${displayHour}${isPM ? 'p' : 'a'}`;
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new BulletHistory();
});
